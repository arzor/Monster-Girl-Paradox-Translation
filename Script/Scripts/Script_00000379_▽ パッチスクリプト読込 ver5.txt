
SCRIPT_UPDATE_ID = "qoiekacb"

=begin

もんむす・くえすと！ＲＰＧ
　パッチスクリプト読込 ver5  2017/06/10

「▼ メイン」のすぐ上に配置する

Patch/patch.rb がパッチファイル

パッチファイルの1～4行目は以下のようにする
  1:# 936188
  2:
  3:p_version = "v1.20"
  4:$patch_ver = "#{p_version}.00"

1行目は「# (認証番号)」
3行目は「p_version = "(本体バージョン)"」
4行目は「$patch_ver = "#{p_version}.(パッチバージョン)"」

3行目と4行目のバージョン番号は、タイトル画面左上やエラーメッセージに表示される

パッチ読み込み時、1行目の認証番号が「正常認証番号」と合致しなければ
・戦闘テスト以外ならエラー終了
・戦闘テストなら正常認証番号をメッセージボックスで表示し、その後に戦闘テスト開始

正常認証番号は「パッチファイルの２行目以降の全内容」から
　「改行コード、空白、数値」を除いた全文字に依存して決まる
バージョン番号の数値を書き変えただけでは、正常認証番号は変わらない
具体的には、上記全文字の文字コード番号(整数)の総和をnとして
　「n」×「nの平方根(小数)の右端の数を、1ケタの整数とした値」とする

=end

#==============================================================================
# ■ NWPatch
#==============================================================================
module NWPatch
  DIR_NAME  = "Patch"
  FILE_NAME = "Patch.rb"
  PATH      = DIR_NAME + "/" + FILE_NAME
  
  def self.included?
    return $patch_ver
  end
  def self.ver_str(t = "")
    return included? ? "#{$patch_ver}#{t}" : ""
  end
  def self.ver_name(t = "")
    return included? ? "Ver#{ver_str}#{t}" : ""
  end
end

if File.exist?(NWPatch::PATH)
  s = File.read(NWPatch::PATH)
  s1 = ""
  n = 0
  s.each_line do |line|
    if s1 == ""
      s1 = line
    else
      line.gsub(/\d|\s/, "").each_char {|c| n += c.unpack("U*")[0] }
    end
  end
  true_pass = n * Math.sqrt(n).to_s[-1].to_i
  if s1 =~ /^#\s*(\d+)/ and $1.to_i == true_pass
    if $TEST
      p "パッチの認証番号が正常です　パッチを読み込みました"
    end
  else
    if $BTEST
      mes  = "パッチの認証番号が不正ですが、テストプレイ中のため、パッチを読み込んで実行します"
      mes += "\n以下に正しい認証番号を表示します"
      mes += "\n\nPatch/Patch.rb の1行目を次のように変更してください"
      mes += "\n\n##{true_pass}"
      msgbox mes
    elsif Object.const_defined?(:PATCH_TEST)
      p "PatchError  - パッチの内容が不正です　ダウンロードし直してください"
      p "PatchError  - パッチの内容が不正です　ダウンロードし直してください"
      p "PatchError  - パッチの内容が不正です　ダウンロードし直してください"
      p "PatchError  - パッチの内容が不正です　ダウンロードし直してください"
      p "PatchError  - パッチの内容が不正です　ダウンロードし直してください"
      p "PatchError  - パッチの内容が不正です　ダウンロードし直してください"
      p "PatchError  - パッチの内容が不正です　ダウンロードし直してください"
      p "PatchError  - パッチの内容が不正です　ダウンロードし直してください"
      p "PatchError  - パッチの内容が不正です　ダウンロードし直してください"
      p "true_pass:#{true_pass}"
    else
      raise "PatchError  - パッチの内容が不正です　ダウンロードし直してください"
    end
  end
  eval(s)
end

#==============================================================================
# ■ Scene_Title
#==============================================================================
class Scene_Title < Scene_Base
  #--------------------------------------------------------------------------
  # ● 前景の作成
  #--------------------------------------------------------------------------
  def create_foreground
    @foreground_sprite = Sprite.new
    @foreground_sprite.bitmap = Bitmap.new(Graphics.width, Graphics.height)
    @foreground_sprite.z = 100
    draw_game_title if $data_system.opt_draw_title
    @foreground_sprite.bitmap.font.size = 24
    rect = Rect.new(4, 0, Graphics.width, @foreground_sprite.bitmap.font.size)
    @foreground_sprite.bitmap.draw_text(rect, NWPatch.ver_str)
  end
end

#==============================================================================
#    Global Text Codes [VXA]
#    Version: 1.0a
#    Author: modern algebra (rmrk.net)
#    Date: April 5, 2012
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Description:
#
#    This script allows you to use special message codes in any window, not
#   just message windows and help windows. Want to add an icon next to the 
#   menu commands? With this script you can do that and more.
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Instructions:
#
#    Simply paste this script into its own slot above Main and below Materials
#   and other custom scripts.
#
#    There are two settings for this script - automatic and manual. If set to
#   automatic, then all you will need to do is put any of the special message
#   codes in anything and they will automatically work. If set to manual, then
#   you will also need to type the following code somewhere in the text field 
#   to activate it: \*
#
#    The following default codes are available:
#
# \c[n] - Set the colour of the text being drawn to the nth colour of the 
#     Windowskin palette. 0 is the normal color and 16 is the system color.
# \i[n] - Draw icon with index n.
# \p[n] - Draw the name of the actor in the xth position in the party. 1 is 
#     the party leader, 2 is the second member, etc.
# \n[n] - Draw the name of the actor with ID n
# \v[n] - Draw the value of variable with ID n.
# \g - Draws the unit of currency.
#
#    Depending on whether you are using any custom message script, you may have 
#   additional message codes at your disposal. This script is mostly compatible
#   with my ATS and every code except \x and ones related to message control 
#   will work.
#==============================================================================

$imported = {} unless $imported
$imported[:MAGlobalTextCodes] = true
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
#  Editable Region
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#  MAGTC_MANUAL_CODES - If this is true, then you must put a \* code in any 
# field that you want to have codes interpreted in. Otherwise, codes will 
# always automatically be interpreted. The recommended value for this is true,
# as the process for drawing text with codes is much slower than the process 
# for drawing text without codes.
MAGTC_MANUAL_CODES = true
#  MAGTC RCODES - This feature is designed to overcome the space limitations in
# much of the database - since codes take so much of that space, it might be
# difficult to write everything you want into one of those fields. This feature
# permits you to write the term you want in to the following array, and then 
# access it in the database with the code \r[n], where n is the ID you assign 
# to the phrase in the following way:
#
#    n => "replacement",
#
# Please note that: it is =>, not =; the replacement must be within quotation 
# marks; and there must be a comma after every line. If using double quotation
# marks ("", not ''), then you need to use two backslashes to access codes 
# instead of one (\\c[1], not \c[1]).
#
#  EXAMPLE:
#   0 => "\\i[112]\\c[14]New Game\\c[0]",
#
#  Under the New Game field in the Terms of the Database, all I would then need 
# to put is:
#    \*\r[0]
#  and it would be the same as if I had put:
#    \*\i[112]\c[14]New Game\c[0]
MAGTC_RCODES = { # <- Do not touch
  0 => "\\i[112]\\c[14]New Game\\c[0]", # Example
  1 => "", # You can make as many of these as you want
  2 => "\\i[40]Blood Hound",
#||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
#  END Editable Region
#//////////////////////////////////////////////////////////////////////////////
}
MAGTC_RCODES.default = ""

#==============================================================================
# ** Window_Base
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Summary of Changes:
#    aliased methods - draw_text; convert_escape_characters; process_new_line;
#      reset_font_settings
#    new methods - magtc_align_x; magtc_test_process_escape_character;
#      magtc_calc_line_width
#==============================================================================

class Window_Base
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Draw Text
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  alias ma_gtc_drwtxt_3fs1 draw_text
  def draw_text(*args, &block)
    # Get the arguments
    if args[0].is_a?(Rect)
        x, y, w, h = args[0].x, args[0].y, args[0].width, args[0].height
        text, align = *args[1, 2]
      else
        x, y, w, h, text, align = *args[0, 6]
      end
    align = 0 unless align
    #  Draw normally if text is not a string, draw normally if the text is not
    # long enough to hold a code, and draw normally when the script is set to 
    # manual and \* is included in the text
      if !text.is_a?(String) || text.size < 2 || (MAGTC_MANUAL_CODES && text[/\\\*/].nil?)
        ma_gtc_drwtxt_3fs1(*args, &block) # Run Original Method
      else
      @magtc_reset_font = contents.font.dup # Do not automatically reset font
      @magtc_rect, @magtc_align = Rect.new(x, y, w, h), align
      # Get first line of the text to test for alignment
      @magtc_test_line = convert_escape_characters(text[/.*/])
      y += [(h - calc_line_height(@magtc_test_line)) / 2, 0].max
      # Draw text with message codes
        draw_text_ex(magtc_align_x(x), y, text)
      @magtc_reset_font = nil # Do not automatically reset font
      @magtc_rect, @magtc_align = nil, nil # Reset Rect and Alignment
      end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Convert Escape Characters
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  alias ma_gtc_convescchar_5tk9 convert_escape_characters
  def convert_escape_characters(text, *args, &block)
    # Remove \* codes
    new_text = text.gsub(/\\\*/, "")
    # Substitute for the R Codes
    new_text.gsub!(/\\[Rr]\[(\d+)\]/) { MAGTC_RCODES[$1.to_i].to_s }
    ma_gtc_convescchar_5tk9(new_text, *args, &block) # Call Original Method
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Reset Font Settings
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  alias magtc_resetfonts_4ga5 reset_font_settings
  def reset_font_settings(*args, &block)
    magtc_resetfonts_4ga5(*args, &block) # Call Original Method
    contents.font = @magtc_reset_font if @magtc_reset_font
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Process New Line
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  alias magtc_prcsnewl_5gn9 process_new_line
  def process_new_line(text, pos, *args, &block)
    magtc_prcsnewl_5gn9(text, pos, *args, &block) # Run Original Method
    if @magtc_align && @magtc_rext
      @magtc_test_line = text[/.*/] # Get new line
      pos[:x] = magtc_align_x       # Get the correct x, depending on alignment
    end
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Get Alignment X
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def magtc_align_x(start_x = @magtc_rect.x)
    return start_x unless (@magtc_rect && @magtc_align && @magtc_test_line) || @magtc_align != 0
    tw = magtc_calc_line_width(@magtc_test_line)
    case @magtc_align
    when 1 then return start_x + ((@magtc_rect.width - tw) / 2)
    when 2 then return start_x + (@magtc_rect.width - tw)
    end
    start_x
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Calc Line Width
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def magtc_calc_line_width(line)
    # Remove all escape codes
    line = line.clone
    line.gsub!(/[\n\r\f]/, "")
    real_contents = contents # Preserve Real Contents
    # Create a dummy contents
    self.contents = Bitmap.new(@magtc_rect.width, @magtc_rect.height)
    reset_font_settings
    pos = {x: 0, y: 0, new_x: 0, height: calc_line_height(line)}
    tw = 0
    while line[/^(.*?)\e(.*)/]
      tw += text_size($1).width
      line = $2
      # Remove all ancillaries to the code, like parameters
      code = obtain_escape_code(line)
      magtc_test_process_escape_character(code, line, pos)
    end
    #  Add width of remaining text, as well as the value of pos[:x] under the 
    # assumption that any additions to it are because the special code is 
    # replaced by something which requires space (like icons)
    tw += text_size(line).width + pos[:x]
    self.contents.dispose # Dispose dummy contents
    self.contents = real_contents # Restore real contents
    return tw
  end
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # * Test Process Escape Character
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  def magtc_test_process_escape_character(code, text, pos)
    if $imported[:ATS_SpecialMessageCodes] && ['X', 'HL'].include?(code.upcase)
      obtain_escape_param(text)
      return
    end
    process_escape_character(code, text, pos)
  end
end

#==============================================================================
# EX's scripts for overwriting enemy/place/etc names.
# - * - Encoding: utf-8 - * -
=begin
=Extension Script(s) For MGQ Paradox
=Library Note Name Data setting section by MGQ EX

Adds Features For MGQ Paradox
* ENEMY_SPECIAL_NAME		Used To Supplement Enemy Note: <図鑑名称:
* RACE_SPECIAL_NAME			Used To Supplement Category & Note: <カテゴリー：
* PLACE_NAME				Used To Supplement Place Names
* Various Word Wrap Corrections
* Includes Scripts: YEA - Ace Message System (Unofficial Edit)
					Basic Window Resizer v1.1 (Unofficial Edit)

== Update history
Date Version Author Comment
08/14/2015 3.0,0 MGQ EX


=end
#==============================================================================
# ■ NWConst::Library
#==============================================================================
module NWConst::Library  
  # Special Settings
  ENABLE_SAVE_DEBUG = false
  
  #Special Names
  #Found In Database Note Section
  # <図鑑名称:SPECIAL_NAME>
  # <種族:SPECIAL_NAME>
  
  #Enemy Special Names
  ENEMY_SPECIAL_NAME = [
    ["バニースライム娘（ボス）", "Bunny Slime (Boss)"],
    ["ヌルコ", "Nuruko"],
    ["ダークエルフ（剣）", "Dark Elf Fencer"],
    ["ダークエルフ（召喚）", "Dark Elf Mage"],
    ["ゾンビ娘Ａ", "Zombie Girl A"],
    ["ゾンビ娘Ｂ", "Zombie Girl B"],
    ["ゾンビ娘Ｃ", "Zombie Girl C"],
    ["ゾンビ娘Ｄ", "Zombie Girl D"],
    ["フェアリーズＡ", "Fairies A"],
    ["フェアリーズＢ", "Fairies B"],
    ["フェアリーズＣ", "Fairies C"],
    ["フェアリーズＤ", "Fairies D"],
    ["フェアリーズＥ", "Fairies E"],
    ["フェアリーズＦ", "Fairies F"],
    ["リザードシーフＡ", "Lizard Thief A"],
    ["リザードシーフＢ", "Lizard Thief B"],
    ["アリスフィーズ16世（冥府）", "Alipheese The 16th (Hades)"],
    ["ラナエル（異世界）", "Archangel Ranael (Alt)"],
    ["ナガエル（異世界）", "Principality Nagael (Alt)"],
    ["一反木綿娘Ａ", "Ittan-Momen A"],
    ["一反木綿娘Ｂ", "Ittan-Momen B"],
    ["一反木綿娘Ｃ", "Ittan-Momen C"],
    ["カエル娘Ａ", "Frog Girl A"],
    ["カエル娘Ｂ", "Frog Girl B"],
    ["アルマエルマ（1回目）", "Alma Elma (1)"],
    ["グランベリア（1回目）", "Granberia (1)"],
    ["グノーシス（1回目）", "Gnosis (1)"],
    ["シオン（1回目）", "Zion (1)"],
    ["グールＡ", "Ghoul A"],
    ["グールＢ", "Ghoul B"],
    ["グールＣ", "Ghoul C"],
    ["リリス（1回目）", "Lilith (1)"],
    ["ベルゼバブＡ", "Beelzebub A"],
    ["ベルゼバブＢ", "Beelzebub B"],
    ["ベルゼバブＣ", "Beelzebub C"],
    ["サキュバスＡ", "Succubus A"],
    ["サキュバスＢ", "Succubus B"],
    ["サキュバスＣ", "Succubus C"],
    ["サキュバスＤ", "Succubus D"],
    ["グランベリア（2回目）", "Granberia (2)"],
    ["ドリアード（緑）", "Dryad"],
    ["ドリアード（青）", "Dark Dryad"],
    ["アラクネＡ", "Arachne A"],
    ["アラクネＢ", "Arachne B"],
    ["アラクネＣ", "Arachne C"],
    ["黒華（1回目）", "Black Dahlia (1)"],
    ["黒蛇（1回目）", "Black Mamba (1)"],
    ["黒薔薇（1回目）", "Black Rose (1)"],
    ["黒のアリス（第1形態）", "Black Alice (1st Form)"],
    ["黒のアリス（第2形態）", "Black Alice (2nd Form)"],
    ["黒のアリス（第3形態）", "Black Alice (3rd Form)"],
    ["天使兵Ａ", "Angel Soldier A"],
    ["天使兵Ｂ", "Angel Soldier B"],
    ["天使兵Ｃ", "Angel Soldier C"],
    ["天使兵Ｄ", "Angel Soldier D"],
    ["天使兵Ｅ", "Angel Soldier E"],
    ["トリニティＡ", "Trinity A"],
    ["トリニティＢ", "Trinity B"],
    ["トリニティＣ", "Trinity C"],
    ["エデン（1回目）", "Eden (1)"],
    ["フェルナンデス（ゾンビ）", "Fernandez (Zombie)"],
    ["タイタニア（ゾンビ）", "Titania (Zombie)"],
    ["ロザ（ゾンビ）", "Roza (Zombie)"],
    ["クィーンラミア（ゾンビ）", "Queen Lamia (Zombie)"],
    ["クィーンハーピー（ゾンビ）", "Former Queen Harpy (Zombie)"],
    ["クィーンスキュラ（ゾンビ）", "Queen Scylla (Zombie)"],
    ["アルマエルマ（2回目）", "Alma Elma (2)"],
    ["ギルゴーン（1回目）", "Gilgorn (1)"],
    ["サキュバス（SQ）", "Nightmare (SQ)"],
    ["ベル（1回目）", "Bell (1)"],
    ["リラ（1回目）", "Lyla (1)"],
    ["ミュゼット（1回目）", "Musette (1)"],
    ["フルビュア（1回目）", "Fulbeua (1)"],
    ["妲己（1回目）", "Daji (1)"],
    ["エスト（1回目）", "Est (1)"],
    ["エスト（最終）", "Est (Final)"],
    ["エスト（2回目）", "Est (2)"],
    ["ベル（2回目）", "Bell (2)"],
    ["リラ（2回目）", "Lyla (2)"],
    ["ミュゼット（2回目）", "Musette (2)"],
    ["フルビュア（2回目）", "Fulbeua (2)"],
    ["ギルゴーン（2回目）", "Gilgorn (2)"],
    ["大明海", "Daimyokai"],
    ["妲己（2回目）", "Daji (2)"],
    ["サキュバス（半夢魔）", "Demi-Nightmare"],
    ["サキュバス（SR）", "Nightmare (SR)"],
    ["カサンドラ（大）", "Cassandra (Restored)"],
  ]
  
  #Race Special Names
  RACE_SPECIAL_NAME = [
    ["メイン", "Main"],
    ["アポトーシス", "Apoptosis"],
    ["エルフ", "Elf"],
    ["キメラ", "Chimera"],
    ["ゴースト", "Ghost"],
    ["スキュラ", "Scylla"],
    ["スライム", "Slime"],
    ["その他", "Other"],
    ["ゾンビ", "Zombie"],
    ["ドール", "Doll"],
    ["ラミア", "Lamia"],
    ["ロイド", "Roid"],
    ["亜人", "Demi-Human"],
    ["人間", "Human"],
    ["人魚", "Mermaid"],
    ["吸血鬼", "Vampire"],
    ["天使", "Angel"],
    ["女神", "Goddess"],
    ["妖狐", "Kitsune"],
    ["妖精", "Fairy"],
    ["妖魔", "Yoma"],
    ["植物", "Plant"],
    ["海棲種", "Sea-Dweller"],
    ["淫魔", "Succubus"],
    ["竜", "Dragon"],
    ["虫", "Insect"],
    ["邪神", "Evil Goddess"],
    ["陸棲種", "Land-Dweller"],
    ["魔獣", "Beast"],
    ["魔王", "Monster Lord"],
    ["鳥", "Harpy"],
    ["コラボ", "Collab"],	
  ]
  
  #Skill Special Names
  SKILL_SPECIAL_NAME = [
    ["アークイビー（女）", "Arc Ivy (F)"],
    ["アークイビー（男）", "Arc Ivy (M)"],
    ["あかなめ乳首這い（女）", "Akaname Nipple Crawl (F)"],
    ["あかなめ乳首這い（男）", "Akaname Nipple Crawl (M)"],
    ["あかなめ舌園（女）", "Akaname Tongue Garden (F)"],
    ["あかなめ舌園（発動）", "Akaname Tongue Garden (Init)"],
    ["あかなめ舌園（継続）", "Akaname Tongue Garden (Cont)"],
    ["アクアストローク（女）", "Aqua Stroke (F)"],
    ["アクアストローク（男）", "Aqua Stroke (M)"],
    ["アクアプリズン（女）", "Aqua Prison (F)"],
    ["アクアプリズン（男）", "Aqua Prison (M)"],
    ["アゲハ口腔吸精（女）", "Swallowtail's Sucking (F)"],
    ["アゲハ口腔吸精（男）", "Swallowtail's Sucking (M)"],
    ["アゲハ袖愛撫（女）", "Swallowtail's Sleeve Caress (F)"],
    ["アゲハ袖愛撫（男）", "Swallowtail's Sleeve Caress (M)"],
    ["アネモネホールド（女）", "Anemone Hold (F)"],
    ["アネモネホールド（男）", "Anemone Hold (M)"],
    ["アビスドレイン（女）", "Abyss Drain (F)"],
    ["アビスドレイン（発動）", "Abyss Drain (Init)"],
    ["アビスドレイン（継続）", "Abyss Drain (Cont)"],
    ["アメーバードレイン（女）", "Amoeba Drain (F)"],
    ["アメーバードレイン（男）", "Amoeba Drain (M)"],
    ["アメーバーヘイズ（女）", "Amoeba Haze (F)"],
    ["アメーバーヘイズ（男）", "Amoeba Haze (M)"],
    ["アラクネスレッド（女）", "Arachne Thread (F)"],
    ["アラクネスレッド（男）", "Arachne Thread (M)"],
    ["アラクネ・リプロア（発動）", "Arachne Repro (Init)"],
    ["アラクネ・リプロア（継続）", "Arachne Repro (Cont)"],
    ["アラクネルイン（発動）", "Arachne Ruin (Init)"],
    ["アラクネルイン（継続）", "Arachne Ruin (Cont)"],
    ["アリゲーターボア（女）", "Alligator Vore (F)"],
    ["アリゲーターボア（男）", "Alligator Vore (M)"],
    ["アルケミスエウリア（女）", "Alchemist Euria (F)"],
    ["アルケミスエウリア（男）", "Alchemist Euria (M)"],
    ["アンシェントレイプ（発動）", "Ancient Rape (Init)"],
    ["アンシェントレイプ（継続）", "Ancient Rape (Cont)"],
    ["イクステンタクル（女）", "EX Tentacle (F)"],
    ["イクステンタクル（男）", "EX Tentacle (M)"],
    ["インフェルノ・デ・スキュラ（発動）", "Inferno de Scylla (Init)"],
    ["インフェルノ・デ・スキュラ（継続）", "Inferno de Scylla (Cont)"],
    ["インモラルレイド（女）", "Immoral Raid (F)"],
    ["インモラルレイド（男）", "Immoral Raid (M)"],
    ["ヴァルト機檻（女）", "Valto Mech Cage (F)"],
    ["ヴァルト機檻（発動）", "Valto Mech Cage (Init)"],
    ["ヴァルト機檻（継続）", "Valto Mech Cage (Cont)"],
    ["ヴェータラボア（女）", "Vetala Vore (F)"],
    ["ヴェータラボア（発動）", "Vetala Vore (Init)"],
    ["ヴェータラボア（継続）", "Vetala Vore (Cont)"],
    ["エアレイプ（発動）", "Air Rape (Init)"],
    ["エアレイプ（継続）", "Air Rape (Cont)"],
    ["エクスタシーキュラス（発動）", "Ecstasy Caress (Init)"],
    ["エクスタシーキュラス（継続）", "Ecstasy Caress (Cont)"],
    ["エクスタシーワーム（女）", "Ecstasy Worm (F)"],
    ["エクスタシーワーム（男）", "Ecstasy Worm (M)"],
    ["エミリのおもちゃ（女）", "Emily's Toy (F)"],
    ["エミリのおもちゃ（男）", "Emily's Toy (M)"],
    ["エリザベートの吸血（女）", "Elizabeth's Bloodsucking (F)"],
    ["エリザベートの吸血（男）", "Elizabeth's Bloodsucking (M)"],
    ["エルフの魔膣", "Elven Queen's Vagina"],
    ["エロスハンド（女）", "Eros's Hand (F)"],
    ["エロスハンド（男）", "Eros's Hand (M)"],
    ["カーミラの吸血（女）", "Carmilla's Blood Sucking(F)"],
    ["カーミラの吸血（男）", "Carmilla's Blood Sucking(M)"],
    ["からくりおっぱいギミック（女）", "Breast Doll's Gimmick (F)"],
    ["からくりおっぱいギミック（男）", "Breast Doll's Gimmick (M)"],
    ["からくりの手淫（女）", "Mechanical Hand Job (F)"],
    ["からくりの手淫（男）", "Mechanical Hand Job (M)"],
    ["カレス・イビー（女）", "Ivy Caress (F)"],
    ["カレス・イビー（男）", "Ivy Caress (M)"],
    ["カレスワーム（女）", "Worm Caress (F)"],
    ["カレスワーム（男）", "Worm Caress (M)"],
    ["キューブヘブン（女）", "Cube Heaven (F)"],
    ["キューブヘブン（男）", "Cube Heaven (M)"],
    ["グリーンドロウ（女）", "Green Draw (F)"],
    ["グリーンドロウ（男）", "Green Draw (M)"],
    ["グリズリーレイプ（発動）", "Grizzly Rape (Init)"],
    ["グリズリーレイプ（継続）", "Grizzly Rape (Cont)"],
    ["ケンタウロスレイプ（発動）", "Kentauros Rape (Init)"],
    ["ケンタウロスレイプ（継続）", "Kentauros Rape (Cont)"],
    ["ゴーストレイプ（発動）", "Ghost Rape (Init)"],
    ["ゴーストレイプ（継続）", "Ghost Rape (Cont)"],
    ["コブラアナリシア（女）", "Cobra Anal (F)"],
    ["コブラアナリシア（男）", "Cobra Anal (M)"],
    ["ご奉仕手淫（女）", "Service:Hand (F)"],
    ["ご奉仕手淫（男）", "Service:Hand (M)"],
    ["ご奉仕口淫（女）", "Service:Mouth (F)"],
    ["ご奉仕口淫（男）", "Service:Mouth (M)"],
    ["ご奉仕吸精（発動）", "Service:Sucking (Init)"],
    ["ご奉仕吸精（継続）", "Service:Sucking (Cont)"],
    ["ご奉仕天国（女）", "Service:Heaven (F)"],
    ["ご奉仕天国（男）", "Service:Heaven (M)"],
    ["ご奉仕締め上げ（女）", "Service:Holding (F)"],
    ["ご奉仕締め上げ（男）", "Service:Holding (M)"],
    ["ご奉仕触手（女）", "Service:Tentacle (F)"],
    ["ご奉仕触手（男）", "Service:Tentacle (M)"],
    ["サイコドレイン（女）", "Psycho Drain (F)"],
    ["サイコドレイン（男）", "Psycho Drain (M)"],
    ["サタニックプレッシャー（女）", "Satanic Pressure (F)"],
    ["サタニックプレッシャー（男）", "Satanic Pressure (M)"],
    ["サボテン令嬢の受精（発動）", "Cactus Pollination (Init)"],
    ["サボテン令嬢の受精（継続）", "Cactus Pollination (Cont)"],
    ["サボレスボーン（女）", "Sables Bon (F)"],
    ["サボレスボーン（発動）", "Sables Bon (Init)"],
    ["サボレスボーン（継続）", "Sables Bon (Cont)"],
    ["ジェネラルテイル（女）", "General's Tail (F)"],
    ["ジェネラルテイル（男）", "General's Tail (M)"],
    ["ジェネラルレイプ（発動）", "General's Rape (Init)"],
    ["ジェネラルレイプ（継続）", "General's Rape (Cont)"],
    ["ジェリードロウ（女）", "Jelly Draw (F)"],
    ["ジェリードロウ（男）", "Jelly Draw (M)"],
    ["ジェリーヘブン（女）", "Jelly Heaven (F)"],
    ["ジェリーヘブン（発動）", "Jelly Heaven (Init)"],
    ["ジェリーヘブン（継続）", "Jelly Heaven (Cont)"],
    ["ジェルプリズン（女）", "Gel Prison (F)"],
    ["ジェルプリズン（発動）", "Gel Prison (Init)"],
    ["ジェルプリズン（継続）", "Gel Prison (Cont)"],
    ["シスターレイプ（発動）", "Nun Rape (Init)"],
    ["シスターレイプ（継続）", "Nun Rape (Cont)"],
    ["しゃぶる（女）", "Suck (F)"],
    ["しゃぶる（男）", "Suck (M)"],
    ["シャングリラスクリュー（女）", "Shangri-La Screw (F)"],
    ["シャングリラスクリュー（男）", "Shangri-La Screw (M)"],
    ["ジントレル採精器（女）", "Syringe Extraction Method (F)"],
    ["ジントレル採精器（男）", "Syringe Extraction Method (M)"],
    ["スカートじゅるじゅる（女）", "Sucking Skirt (F)"],
    ["スカートじゅるじゅる（男）", "Sucking Skirt (M)"],
    ["ストーンレイプ（発動）", "Stone Rape (Init)"],
    ["ストーンレイプ（継続）", "Stone Rape (Cont)"],
    ["スネークエンド（発動）", "Snake End (Init)"],
    ["スネークエンド（継続）", "Snake End (Cont)"],
    ["スネークハンズ（女）", "Snake Hands (F)"],
    ["スネークハンズ（男）", "Snake Hands (M)"],
    ["スプラッシュタン（女）", "Tongue Splash (F)"],
    ["スプラッシュタン（男）", "Tongue Splash (M)"],
    ["スプレッドワーム（女）", "Worm Spread (F)"],
    ["スプレッドワーム（男）", "Worm Spread (M)"],
    ["スライム股間責め（女）", "Slime Genital Teasing (F)"],
    ["スライム股間責め（男）", "Slime Genital Teasing (M)"],
    ["せるか・すなめ（女）", "Sacrifice Tasting (F)"],
    ["せるか・すなめ（男）", "Sacrifice Tasting (M)"],
    ["ダチョウレイプ（発動）", "Ostrich Rape (Init)"],
    ["ダチョウレイプ（継続）", "Ostrich Rape (Cont)"],
    ["ツインエナジードレイン（発動）", "Twin Energy Drain (Init)"],
    ["ツインエナジードレイン（継続）", "Twin Energy Drain (Cont)"],
    ["ツインドレインテイル（女）", "Twin Tail Drain (F)"],
    ["ツインドレインテイル（男）", "Twin Tail Drain (M)"],
    ["ツタ拘束（女）", "Ivy Restraint (F)"],
    ["ツタ拘束（男）", "Ivy Restraint (M)"],
    ["テイルドレイン・ドーラ（女）", "Tail Drain:Dora (F)"],
    ["テイルドレイン・ドーラ（発動）", "Tail Drain:Dora (Init)"],
    ["テイルドレイン・ドーラ（継続）", "Tail Drain:Dora (Cont)"],
    ["テンタクルカレス（女）", "Tentacle Caress (F)"],
    ["テンタクルカレス（男）", "Tentacle Caress (M)"],
    ["トランシルヴァニアの夜陰（発動）", "Transylvania Midnight (Init)"],
    ["トランシルヴァニアの夜陰（継続）", "Transylvania Midnight (Cont)"],
    ["ドレインハンド（女）", "Drain Hand (F)"],
    ["ドレインハンド（男）", "Drain Hand (M)"],
    ["ドレインワーム（女）", "Drain Worm (F)"],
    ["ドレインワーム（男）", "Drain Worm (M)"],
    ["なめなめ（女）", "Lick (F)"],
    ["なめなめ（男）", "Lick (M)"],
    ["ヌルヌル触手股間責め（女）", "Slimy Tentacle Crotch Torture (F)"],
    ["ヌルヌル触手股間責め（男）", "Slimy Tentacle Crotch Torture (M)"],
    ["ネバネバ腺毛（女）", "Sticky Hairs (F)"],
    ["ネバネバ腺毛（男）", "Sticky Hairs (M)"],
    ["パープルドロウ（女）", "Purple Draw (F)"],
    ["パープルドロウ（男）", "Purple Draw (M)"],
    ["バキュームテイル（女）", "Vacuum Tail (F)"],
    ["バキュームテイル（男）", "Vacuum Tail (M)"],
    ["ハピネス・ロンド（発動）", "Happiness Rondo (Init)"],
    ["ハピネス・ロンド（継続）", "Happiness Rondo (Cont)"],
    ["バブルズシェイク（発動）", "Bubble Shake (Init)"],
    ["バブルズシェイク（継続）", "Bubble Shake (Cont)"],
    ["パラライズワーム（女）", "Paralyze Worm (F)"],
    ["パラライズワーム（男）", "Paralyze Worm (M)"],
    ["ビーナストラップ（女）", "Venus Trap (F)"],
    ["ビーナストラップ（男）", "Venus Trap (M)"],
    ["ビーナスベンド（女）", "Venus Bend (F)"],
    ["ビーナスベンド（男）", "Venus Bend (M)"],
    ["ヒッププレス（発動）", "Ass Press (Init)"],
    ["ヒッププレス（継続）", "Ass Press (Cont)"],
    ["ヒトデカレス（女）", "Starfish Caress (F)"],
    ["ヒトデカレス（男）", "Starfish Caress (M)"],
    ["ヒトデしがみつき（女）", "Starfish Cling (F)"],
    ["ヒトデしがみつき（男）", "Starfish Cling (M)"],
    ["ファナティックダリア（女）", "Fanatic Dahlia (F)"],
    ["ファナティックダリア（男）", "Fanatic Dahlia (M)"],
    ["プラントサック（女）", "Plant Suck (F)"],
    ["プラントサック（男）", "Plant Suck (M)"],
    ["プリエステス・ヘア（女）", "Priestess Hair (F)"],
    ["プリエステス・ヘア（男）", "Priestess Hair (M)"],
    ["プリンセスえっち（発動）", "Princess's Perversion (Init)"],
    ["プリンセスえっち（継続）", "Princess's Perversion (Cont)"],
    ["プリンセス尾ヒレずり（女）", "Princess's Tail Rub (F)"],
    ["プリンセス尾ヒレずり（男）", "Princess's Tail Rub (M)"],
    ["ブルードロウ（女）", "Blue Draw (F)"],
    ["ブルードロウ（男）", "Blue Draw (M)"],
    ["ブロブドロウ（女）", "Blob Draw (F)"],
    ["ブロブドロウ（男）", "Blob Draw (M)"],
    ["ブロブヘブン（女）", "Blob Heaven (F)"],
    ["ブロブヘブン（発動）", "Blob Heaven (Init)"],
    ["ブロブヘブン（継続）", "Blob Heaven (Cont)"],
    ["ぺトラ・スコルピオ（女）", "Petra Scorpio (F)"],
    ["ぺトラ・スコルピオ（発動）", "Petra Scorpio (Init)"],
    ["ぺトラ・スコルピオ（継続）", "Petra Scorpio (Cont)"],
    ["ヘブンズバスト（女）", "Heaven's Bust (F)"],
    ["ヘブンズバスト（発動）", "Heaven's Bust (Init)"],
    ["ヘブンズバスト（継続）", "Heaven's Bust (Cont)"],
    ["ヘブンズプリズン（女）", "Heaven's Prison (F)"],
    ["ヘブンズプリズン（発動）", "Heaven's Prison (Init)"],
    ["ヘブンズプリズン（継続）", "Heaven's Prison (Cont)"],
    ["ボアワーム（女）", "Vore Worm (F)"],
    ["ボアワーム（発動）", "Vore Worm (Init)"],
    ["ボアワーム（継続）", "Vore Worm (Cont)"],
    ["ポイズンドロウ（女）", "Poison Draw (F)"],
    ["ポイズンドロウ（男）", "Poison Draw (M)"],
    ["マーメイドヘア（女）", "Mermaid Hair (F)"],
    ["マーメイドヘア（男）", "Mermaid Hair (M)"],
    ["マグマスファル（女）", "Magma Bath (F)"],
    ["マグマスファル（男）", "Magma Bath (M)"],
    ["マグマドロウ（女）", "Magma Draw (F)"],
    ["マグマドロウ（男）", "Magma Draw (M)"],
    ["マッドシェイク（女）", "Mud Shake (F)"],
    ["マッドシェイク（男）", "Mud Shake (M)"],
    ["マッドドロウ（女）", "Mud Draw (F)"],
    ["マッドドロウ（男）", "Mud Draw (M)"],
    ["マンティスレイプ（発動）", "Mantis Rape (Init)"],
    ["マンティスレイプ（継続）", "Mantis Rape (Cont)"],
    ["ミイラパッケージ（女）", "Mummy Package (F)"],
    ["ミイラパッケージ（発動）", "Mummy Package (Init)"],
    ["ミイラパッケージ（継続）", "Mummy Package (Cont)"],
    ["ミイラバンデージ（女）", "Mummy Bandage (F)"],
    ["ミイラバンデージ（男）", "Mummy Bandage (M)"],
    ["ミニメルティウォッシュ（女）", "Mini Melty Wash (F)"],
    ["ミニメルティウォッシュ（男）", "Mini Melty Wash (M)"],
    ["ミノタウロスレイプ（発動）", "Minotauros Rape (Init)"],
    ["ミノタウロスレイプ（継続）", "Minotauros Rape (Cont)"],
    ["メルティウォッシュ（女）", "Melty Wash (F)"],
    ["メルティウォッシュ（男）", "Melty Wash (M)"],
    ["メルトシザーズ（女）", "Melt Scissors (F)"],
    ["メルトシザーズ（発動）", "Melt Scissors (Init)"],
    ["メルトシザーズ（継続）", "Melt Scissors (Cont)"],
    ["メロウラフレシア（発動）", "Mellow Rafflesia (Init)"],
    ["メロウラフレシア（継続）", "Mellow Rafflesia (Cont)"],
    ["メロソフィ・エンデ（発動）", "Melo Sophie:End (Init)"],
    ["メロソフィ・エンデ（継続）", "Melo Sophie:End (Cont)"],
    ["やまた・しろろひ（女）", "Eight Head Assault (F)"],
    ["やまた・しろろひ（男）", "Eight Head Assault (M)"],
    ["ラミアの魔膣（発動）", "Lamia's Devilish Vagina (Act.)"],
    ["ラミアの魔膣（継続）", "Lamia's Devilish Vagina (Cont.)"],
    ["リトン搾精器（女）", "Litton Energy Extractor (F)"],
    ["リトン搾精器（男）", "Litton Energy Extractor (M)"],
    ["リボリボハウルン（女）", "Ribo-Ribo Capsule (F)"],
    ["リボリボハウルン（発動）", "Ribo-Ribo Capsule (Init)"],
    ["リボリボハウルン（継続）", "Ribo-Ribo Capsule (Cont)"],
    ["ルーティー・カレス（女）", "Rooty Caress (F)"],
    ["ルーティー・カレス（男）", "Rooty Caress (M)"],
    ["ルーティー・ホールド（女）", "Rooty Hold (F)"],
    ["ルーティー・ホールド（男）", "Rooty Hold (M)"],
    ["ルクスルスロウン（女）", "Luxuru Throne (F)"],
    ["ルクスルスロウン（拘束）", "Luxuru Throne (Bind)"],
    ["ルクスルスロウン（継続）", "Luxuru Throne (Cont)"],
    ["レッドドロウ（女）", "Red Draw (F)"],
    ["レッドドロウ（男）", "Red Draw (M)"],
    ["レティア式触診（女）", "Genital Palpation (F)"],
    ["レティア式触診（男）", "Genital Palpation (M)"],
    ["ロウ固め（女）", "Wax Hardening (F)"],
    ["ロウ固め（男）", "Wax Hardening (M)"],
    ["ワイルドレイプ（発動）", "Wild Rape (Init)"],
    ["ワイルドレイプ（継続）", "Wild Rape (Cont)"],
    ["ワカメ愛撫（女）", "Seaweed Caress (F)"],
    ["ワカメ愛撫（男）", "Seaweed Caress (M)"],
    ["ワカメ蹂躙（女）", "Seaweed Violations (F)"],
    ["ワカメ蹂躙（男）", "Seaweed Violations (M)"],
    ["九十巻舌姦（女）", "Ninety Inch Tongue Wrap (F)"],
    ["九十巻舌姦（発動）", "Ninety Inch Tongue Wrap (Init)"],
    ["九十巻舌姦（継続）", "Ninety Inch Tongue Wrap (Cont)"],
    ["乱れ太夫（発動）", "Courtesan's Pride (Init)"],
    ["乱れ太夫（継続）", "Courtesan's Pride (Cont)"],
    ["人形の手遊び（女）", "Doll's Fingerplay (F)"],
    ["人形の手遊び（男）", "Doll's Fingerplay (M)"],
    ["人魚の洗い手慰（女）", "Mermaid's Cleaning Hand (F)"],
    ["人魚の洗い手慰（男）", "Mermaid's Cleaning Hand (M)"],
    ["体液搾取（女）", "Bodily Fluid Drinking (F)"],
    ["体液搾取（発動）", "Bodily Fluid Drinking (Init)"],
    ["体液搾取（継続）", "Bodily Fluid Drinking (Cont)"],
    ["全身おしゃぶり（女）", "Full-Body Suck (F)"],
    ["全身おしゃぶり（男）", "Full-Body Suck (M)"],
    ["全身吸精（女）", "Full Body Tentacle Drain (F)"],
    ["全身吸精（男）", "Full Body Tentacle Drain (M)"],
    ["全身洗浄（女）", "Full Body Wash (F)"],
    ["全身洗浄（男）", "Full Body Wash (M)"],
    ["全身触手責め（女）", "Full Body Tentacle Torture (F)"],
    ["全身触手責め（男）", "Full Body Tentacle Torture (M)"],
    ["八撫の足（女）", "Eight-Legged Stroke (F)"],
    ["八撫の足（男）", "Eight-Legged Stroke (M)"],
    ["凍てつく陵辱（発動）", "Freezing Rape (Init)"],
    ["凍てつく陵辱（継続）", "Freezing Rape (Cont)"],
    ["動力補給（発動）", "Power Replenishment (Init)"],
    ["動力補給（継続）", "Power Replenishment (Cont)"],
    ["十指手淫（女）", "Ten Finger Masturbation (F)"],
    ["十指手淫（男）", "Ten Finger Masturbation (M)"],
    ["取り込む（発動1）", "Assimilate (Init 1)"],
    ["取り込む（発動2）", "Assimilate (Init 2)"],
    ["口内嫐り（女）", "Oral Fixation (F)"],
    ["口内嫐り（男）", "Oral Fixation (M)"],
    ["同化吸収（女）", "Assimilation Drain (F)"],
    ["同化吸収（継続）", "Assimilation Drain (Cont)"],
    ["吸精（女）", "Fluid Suck (F)"],
    ["吸精（男）", "Fluid Suck (M)"],
    ["吸精ツタ（女）", "Sucking Ivy (F)"],
    ["吸精ツタ（男）", "Sucking Ivy (M)"],
    ["吸精ドレス（女）", "Dress Drain (F)"],
    ["吸精ドレス（男）", "Dress Drain (M)"],
    ["吸精の繭（発動）", "Semen Sucking Cocoon (Init)"],
    ["吸精の繭（継続）", "Semen Sucking Cocoon (Cont)"],
    ["吸精の髪（女）", "Draining Hair (F)"],
    ["吸精の髪（男）", "Draining Hair (M)"],
    ["吸精夜想曲（発動）", "Nocturnal Sucking (Init)"],
    ["吸精夜想曲（継続）", "Nocturnal Sucking (Cont)"],
    ["吸精触手（女）", "Sucking Tentacle (F)"],
    ["吸精触手（男）", "Sucking Tentacle (M)"],
    ["吸血吸精ワーム（女）", "Blood-Sucking Worm (F)"],
    ["吸血吸精ワーム（発動）", "Blood-Sucking Worm (Init)"],
    ["吸血吸精ワーム（継続）", "Blood-Sucking Worm (Cont)"],
    ["嗜虐に嗤う鉄処女（発動）", "Sadistic Iron Maiden (Init)"],
    ["嗜虐に嗤う鉄処女（継続）", "Sadistic Iron Maiden (Cont)"],
    ["土蜘蛛捕獲（女）", "Tsuchigumo Capture (F)"],
    ["土蜘蛛捕獲（男）", "Tsuchigumo Capture (M)"],
    ["地母神の手慰（女）", "Hand of the Earth Mother (F)"],
    ["地母神の手慰（男）", "Hand of the Earth Mother (M)"],
    ["夜夢の蜘蛛（女）", "Dream Spider (F)"],
    ["夜夢の蜘蛛（男）", "Dream Spider (M)"],
    ["夜想搾血（女）", "Nocturnal Bloodsucker (F)"],
    ["夜想搾血（男）", "Nocturnal Bloodsucker (M)"],
    ["大蛇嫐り（女）", "Serpent Teasing (F)"],
    ["大蛇嫐り（男）", "Serpent Teasing (M)"],
    ["大蛇締め（女）", "Serpent Squeeze (F)"],
    ["大蛇締め（男）", "Serpent Squeeze (M)"],
    ["天上のカーマストラ（発動）", "Heavenly Kamasutra (Init)"],
    ["天上のカーマストラ（継続）", "Heavenly Kamasutra (Cont)"],
    ["天境の宴（女）", "Heavenly Feast (F)"],
    ["天境の宴（男）", "Heavenly Feast (M)"],
    ["天魔搾獄（発動）", "Sweet Demonic Prison (Init)"],
    ["天魔搾獄（継続）", "Sweet Demonic Prison (Cont)"],
    ["天魔触撫（女）", "Sweet Demonic Tentacles (F)"],
    ["天魔触撫（男）", "Sweet Demonic Tentacles (M)"],
    ["奉仕手淫（女）", "Service:Hand (F)"],
    ["奉仕手淫（男）", "Service:Hand (M)"],
    ["女王の生殖壺（発動）", "Queen's Stud (Init)"],
    ["女王の生殖壺（継続）", "Queen's Stud (Cont)"],
    ["女王の艶技（女）", "Queen's Unmatched Skill (F)"],
    ["女王の艶技（男）", "Queen's Unmatched Skill (M)"],
    ["女王触手全身責め（女）", "Queen's Tentacle Body Torture (F)"],
    ["女王触手全身責め（男）", "Queen's Tentacle Body Torture (M)"],
    ["女王触手股間責め（女）", "Queen's Tentacle Groin Torture (F)"],
    ["女王触手股間責め（男）", "Queen's Tentacle Groin Torture (M)"],
    ["女皇の吸精（女）", "Empress's Draining (F)"],
    ["女皇の吸精（男）", "Empress's Draining (M)"],
    ["子作りえっち（発動）", "Cat in Heat (Init)"],
    ["子作りえっち（継続）", "Cat in Heat (Cont)"],
    ["子鬼レイプ（発動）", "Oni Rape (Init)"],
    ["子鬼レイプ（継続）", "Oni Rape (Cont)"],
    ["官能の手淫（女）", "Sensual Hands (F)"],
    ["官能の手淫（男）", "Sensual Hands (M)"],
    ["実りなき生殖（発動）", "Fruitless Reproduction (Init)"],
    ["実りなき生殖（継続）", "Fruitless Reproduction (Cont)"],
    ["小鬼の名器（発動）", "Goblin's Signature Vagina (Init)"],
    ["小鬼の名器（継続）", "Goblin's Signature Vagina (Cont)"],
    ["尻尾愛撫（女）", "Tail Caress (F)"],
    ["尻尾愛撫（男）", "Tail Caress (M)"],
    ["尻尾拘束愛撫（女）", "Bound Tail Caress (F)"],
    ["尻尾拘束愛撫（男）", "Bound Tail Caress (M)"],
    ["巨獣蹂躙（発動）", "Giant Beast's Violation (Init)"],
    ["巨獣蹂躙（継続）", "Giant Beast's Violation (Cont)"],
    ["巨腕握り締め（女）", "Giant Arm Sqeeze (F)"],
    ["巨腕握り締め（男）", "Giant Arm Sqeeze (M)"],
    ["巨膣ねじこみ（発動）", "Giant's Vaginal Screw (Init)"],
    ["巨膣ねじこみ（継続）", "Giant's Vaginal Screw (Cont)"],
    ["巻き付く（女）", "Coil (F)"],
    ["巻き付く（男）", "Coil (M)"],
    ["影十字嫐（女）", "Shadow Cross (F)"],
    ["影十字嫐（発動）", "Shadow Cross (Init)"],
    ["影十字嫐（継続）", "Shadow Cross (Cont)"],
    ["影口淫（女）", "Shadow Mouth (F)"],
    ["影口淫（男）", "Shadow Mouth (M)"],
    ["影舞髪淫（女）", "Dancing Shadow Hair (F)"],
    ["影舞髪淫（男）", "Dancing Shadow Hair (M)"],
    ["快楽のつまびき（女）", "Pleasurable Strumming (F)"],
    ["快楽のつまびき（男）", "Pleasurable Strumming (M)"],
    ["快楽の十字架（女）", "Cross of Pleasure (F)"],
    ["快楽の十字架（男）", "Cross of Pleasure (M)"],
    ["快楽の羽根愛撫（女）", "Feather Caress (F)"],
    ["快楽の羽根愛撫（男）", "Feather Caress (M)"],
    ["快楽の風（女）", "Winds of Pleasure (F)"],
    ["快楽の風（男）", "Winds of Pleasure (M)"],
    ["快楽蜜壺漬け（女）", "Honey Pot Soak (F)"],
    ["快楽蜜壺漬け（発動）", "Honey Pot Soak (Init)"],
    ["快楽蜜壺漬け（継続）", "Honey Pot Soak (Cont)"],
    ["恍惚の指使い（女）", "Fingers of Ecstasy (F)"],
    ["恍惚の指使い（男）", "Fingers of Ecstasy (M)"],
    ["恍惚の泡奉仕（女）", "Bubble Service Trance (F)"],
    ["恍惚の泡奉仕（男）", "Bubble Service Trance (M)"],
    ["恍惚の蠕動（女）", "Ecstasy Rub (F)"],
    ["恍惚の蠕動（男）", "Ecstasy Rub (M)"],
    ["悦びの弦（女）", "Strings of Joy (F)"],
    ["悦びの弦（男）", "Strings of Joy (M)"],
    ["悦びの手（女）", "Hand of Pleasure (F)"],
    ["悦びの手（男）", "Hand of Pleasure (M)"],
    ["悦楽の口淫（女）", "Mouth of Pleasure (F)"],
    ["悦楽の口淫（男）", "Mouth of Pleasure (M)"],
    ["悪夢の抱擁（女）", "Nightmare Embrace (F)"],
    ["悪夢の抱擁（発動）", "Nightmare Embrace (Init)"],
    ["悪夢の抱擁（継続）", "Nightmare Embrace (Cont)"],
    ["悪夢の締め付け（女）", "Nightmare Tightening (F)"],
    ["悪夢の締め付け（男）", "Nightmare Tightening (M)"],
    ["愛天使の淫欲（発動）", "Love Angel's Lust (Init)"],
    ["愛天使の淫欲（継続）", "Love Angel's Lust (Cont)"],
    ["戦乙女の天羽（女）", "War Maiden's Heavenly Wings (F)"],
    ["戦乙女の天羽（男）", "War Maiden's Heavenly Wings (M)"],
    ["戦乙女の嫐壺（発動）", "War Maiden's Vagina (Init)"],
    ["戦乙女の嫐壺（継続）", "War Maiden's Vagina (Cont)"],
    ["手誘・魔蜘蛛", "Hand Skill:Spider (F)"],
    ["拘束舐め回し（女）", "Binding Lick (F)"],
    ["拘束舐め回し（発動）", "Binding Lick (Init)"],
    ["拘束舐め回し（継続）", "Binding Lick (Cont)"],
    ["拘束触手愛撫（女）", "Bound Tentacle Caress (F)"],
    ["拘束触手愛撫（男）", "Bound Tentacle Caress (M)"],
    ["搾精イソギンチャクの蠕動（女）", "Anemone Peristalsis (F)"],
    ["搾精イソギンチャクの蠕動（男）", "Anemone Peristalsis (M)"],
    ["搾精の蠕動（女）", "Draining Peristalsis (F)"],
    ["搾精の蠕動（男）", "Draining Peristalsis (M)"],
    ["搾精球（女）", "Drain Sphere (F)"],
    ["搾精球（発動）", "Drain Sphere (Init)"],
    ["搾精球（継続）", "Drain Sphere (Cont)"],
    ["枷躙（女）", "Strumming Shackles (F)"],
    ["枷躙（発動）", "Strumming Shackles (Init)"],
    ["枷躙（継続）", "Strumming Shackles (Cont)"],
    ["歓喜の口（女）", "Mouth of Joy (F)"],
    ["歓喜の口（男）", "Mouth of Joy (M)"],
    ["毒の粘檻（女）", "Sticky Poison Cage (F)"],
    ["毒の粘檻（発動）", "Sticky Poison Cage (Init)"],
    ["毒の粘檻（継続）", "Sticky Poison Cage (Cont)"],
    ["氷の手撫（女）", "Ice Hand Job (F)"],
    ["氷の手撫（男）", "Ice Hand Job (M)"],
    ["流砂の罠（拘束）", "Quicksand Trap (Bind)"],
    ["流髪（女）", "Icicle Hair (F)"],
    ["流髪（男）", "Icicle Hair (M)"],
    ["淑女の口淫（女）", "Lady's Cunnilingus"],
    ["淑女の口淫（男）", "Lady's Fellatio"],
    ["淑女の手淫（女）", "Lady's Masturbation (F)"],
    ["淑女の手淫（男）", "Lady's Masturbation (M)"],
    ["淫ら髪撫（女）", "Indecent Hair (F)"],
    ["淫ら髪撫（男）", "Indecent Hair (M)"],
    ["淫舌ストローク（女）", "Tongue Stroke (F)"],
    ["淫舌ストローク（男）", "Tongue Stroke (M)"],
    ["淫邪の蛇壺（発動）", "Lewd Snake's Vagina (Init)"],
    ["淫邪の蛇壺（継続）", "Lewd Snake's Vagina (Cont)"],
    ["淫邪の蛇髪（女）", "Lewd Snake's Hair (F)"],
    ["淫邪の蛇髪（男）", "Lewd Snake's Hair (M)"],
    ["渇精の肉壺（発動）", "Thirsting Vagina (Init)"],
    ["渇精の肉壺（継続）", "Thirsting Vagina (Cont)"],
    ["溶解口淫（女）", "Dissolving Cunnilingus"],
    ["溶解口淫（男）", "Dissolving Fellatio"],
    ["溶解手淫（女）", "Dissolving Masturbation"],
    ["溶解手淫（男）", "Dissolving Hand Job"],
    ["濡れ尻尾愛撫（女）", "Wet Tail Caress (F)"],
    ["濡れ尻尾愛撫（男）", "Wet Tail Caress (M)"],
    ["濡れ濡れロール（女）", "Wet Wet Roll (F)"],
    ["濡れ濡れロール（男）", "Wet Wet Roll (M)"],
    ["火神連脚（女）", "Fire Spirit's Foot (F)"],
    ["火神連脚（男）", "Fire Spirit's Foot (M)"],
    ["火龍の抱擁（女）", "Fire Spirit's Embrace (F)"],
    ["火龍の抱擁（男）", "Fire Spirit's Embrace (M)"],
    ["牝木繚乱（発動）", "Bloom of the Tree (Init)"],
    ["牝木繚乱（継続）", "Bloom of the Tree (Cont)"],
    ["牡啜りの魔壺（発動）", "Male-Slurping Vagina (Init)"],
    ["牡啜りの魔壺（継続）", "Male-Slurping Vagina (Cont)"],
    ["甘いおしゃぶり（女）", "Sweet Pacifier (F)"],
    ["甘いおしゃぶり（男）", "Sweet Pacifier (M)"],
    ["甘いお口（女）", "Sweet Mouth (F)"],
    ["甘いお口（男）", "Sweet Mouth (M)"],
    ["男殺しの魔蜘蛛", "Hand Skill:Spider (M)"],
    ["疑似捕食機構（女）", "Pseudo-Predation Mechanism (F)"],
    ["疑似捕食機構（発動）", "Pseudo-Predation Mechanism (Init)"],
    ["疑似捕食機構（継続）", "Pseudo-Predation Mechanism (Cont)"],
    ["百合の墓場（発動）", "Graveyard of Lilies (Init)"],
    ["百合の墓場（継続）", "Graveyard of Lilies (Cont)"],
    ["百足責め（女）", "Centipede Torture (F)"],
    ["百足責め（男）", "Centipede Torture (M)"],
    ["百足蹂躙（女）", "Centipede Violation (F)"],
    ["百足蹂躙（男）", "Centipede Violation (M)"],
    ["真夏の夜の夢（女）", "A Midsummer Night's Dream (F)"],
    ["真夏の夜の夢（男）", "A Midsummer Night's Dream (M)"],
    ["破滅の蛇舌（女）", "Snake Tongue of Ruin (F)"],
    ["破滅の蛇舌（男）", "Snake Tongue of Ruin (M)"],
    ["竜撫（女）", "Dragon Hand (F)"],
    ["竜撫（男）", "Dragon Hand (M)"],
    ["粘糸巻き上げ（女）", "Sticky Thread Wrap (F)"],
    ["粘糸巻き上げ（男）", "Sticky Thread Wrap (M)"],
    ["絡み搾る魔性の髪（女）", "Devilish Draining Hair (F)"],
    ["絡み搾る魔性の髪（男）", "Devilish Draining Hair (M)"],
    ["絶技・筒涸らし（発動）", "Ultimate Skill:Pussy Exhaustion (Init)"],
    ["絶技・筒涸らし（継続）", "Ultimate Skill:Pussy Exhaustion (Cont)"],
    ["締め上げる（女）", "Constrict (F)"],
    ["締め上げる（男）", "Constrict (M)"],
    ["羽くすぐり（女）", "Wing Tickle (F)"],
    ["羽くすぐり（男）", "Wing Tickle (M)"],
    ["聖搾蛭（女）", "Sacred Leech (F)"],
    ["聖搾蛭（男）", "Sacred Leech (M)"],
    ["聖獣の愛撫（女）", "Holy Beast's Caress (F)"],
    ["聖獣の愛撫（男）", "Holy Beast's Caress (M)"],
    ["聖蔦の吸精（女）", "Holy Ivy Suction (F)"],
    ["聖蔦の吸精（男）", "Holy Ivy Suction (M)"],
    ["聖髪の天国（女）", "Holy Hair Heaven (F)"],
    ["聖髪の天国（男）", "Holy Hair Heaven (M)"],
    ["聖髪の昇天（女）", "Holy Hair Ascension (F)"],
    ["聖髪の昇天（男）", "Holy Hair Ascension (M)"],
    ["肉器への誘い（女）", "Flesh Hole Invitation (F)"],
    ["肉器への誘い（男）", "Flesh Hole Invitation (M)"],
    ["股間ベロベロ舐め（女）", "Groin Lick (F)"],
    ["股間ベロベロ舐め（男）", "Groin Lick (M)"],
    ["股間繊毛責め（女）", "Trichome Groin Torture (F)"],
    ["股間繊毛責め（男）", "Trichome Groin Torture (M)"],
    ["股間触手責め（女）", "Groin Tentacle Torture (F)"],
    ["股間触手責め（男）", "Groin Tentacle Torture (M)"],
    ["背徳の三重奏（女）", "Immoral Trio (F)"],
    ["背徳の三重奏（男）", "Immoral Trio (M)"],
    ["背徳の甘噛み（女）", "Corrupted Play-biting (F)"],
    ["背徳の甘噛み（男）", "Corrupted Play-biting (M)"],
    ["膣内窒息（発動）", "Vaginal Asphyxiation (Init)"],
    ["膣内窒息（継続）", "Vaginal Asphyxiation (Cont)"],
    ["至福の手淫（女）", "Blissful Masturbation (F)"],
    ["至福の手淫（男）", "Blissful Masturbation (M)"],
    ["舌巻き締め（女）", "Binding Tongue (F)"],
    ["舌巻き締め（男）", "Binding Tongue (M)"],
    ["舌巻き舐め回し（女）", "Bound Tongue Caress (F)"],
    ["舌巻き舐め回し（男）", "Bound Tongue Caress (M)"],
    ["舐め回し（女）", "Lick (F)"],
    ["舐め回し（男）", "Lick (M)"],
    ["花淫（女）", "Lewd Flowers (F)"],
    ["花淫（男）", "Lewd Flowers (M)"],
    ["苗床の抱擁（女）", "Seedbed Embrace (F)"],
    ["苗床の抱擁（男）", "Seedbed Embrace (M)"],
    ["苗床の抱擁（継続）", "Seedbed Embrace (Cont)"],
    ["蕩髪絶技（女）", "Ultimate Hair Charm (F)"],
    ["蛇夜伽（発動）", "Snake Mating (Init)"],
    ["蛇夜伽（継続）", "Snake Mating (Cont)"],
    ["蛭搾（女）", "Leech Suck (F)"],
    ["蛭搾（男）", "Leech Suck (M)"],
    ["蛸撫（女）", "Octopus Pat (F)"],
    ["蛸撫（男）", "Octopus Pat (M)"],
    ["蟲穴交尾（発動）", "Insect Mating (Init)"],
    ["蟲穴交尾（継続）", "Insect Mating (Cont)"],
    ["触手の戯れ（女）", "Tentacle Play (F)"],
    ["触手の戯れ（男）", "Tentacle Play (M)"],
    ["触手乳首責め（女）", "Tentacle Nipple Torture (F)"],
    ["触手乳首責め（男）", "Tentacle Nipple Torture (M)"],
    ["触手吸引（女）", "Tentacle Suck (F)"],
    ["触手吸引（男）", "Tentacle Suck (M)"],
    ["触手吸精（女）", "Tentacle Drain (F)"],
    ["触手吸精（男）", "Tentacle Drain (M)"],
    ["触手愛撫（女）", "Tentacle Caress (F)"],
    ["触手愛撫（男）", "Tentacle Caress (M)"],
    ["触手拘束（女）", "Tentacle Bind (F)"],
    ["触手拘束（男）", "Tentacle Bind (M)"],
    ["触手股間責め（女）", "Tentacle Groin Torture (F)"],
    ["触手股間責め（男）", "Tentacle Groin Torture (M)"],
    ["誘惑花粉の髪（女）", "Seduction Pollen Hair (F)"],
    ["誘惑花粉の髪（男）", "Seduction Pollen Hair (M)"],
    ["貴婦人の遊技（女）", "Lady's Amusement (F)"],
    ["貴婦人の遊技（男）", "Lady's Amusement (M)"],
    ["軟体にゅるにゅるレイプ（発動）", "Soft Body Rape (Init)"],
    ["軟体にゅるにゅるレイプ（継続）", "Soft Body Rape (Cont)"],
    ["逆レイプするのじゃ！", "I'll Rape You! (Init)"],
    ["逆レイプなのじゃ！", "I'll Rape You! (Cont)"],
    ["陵辱テンタクル（継続）", "Tentacle Rape (Cont)"],
    ["陵辱テンタクル（男）", "Tentacle Rape (M)"],
    ["陶酔のウツボカズラ（女）", "Intoxicating Pitcher (F)"],
    ["陶酔のウツボカズラ（発動）", "Intoxicating Pitcher (Init)"],
    ["陶酔のウツボカズラ（継続）", "Intoxicating Pitcher (Cont)"],
    ["集団締め付け（女）", "Group Tightening (F)"],
    ["集団締め付け（男）", "Group Tightening (M)"],
    ["雪女の抱擁（女）", "Yuki-Onna's Hug (F)"],
    ["雪女の抱擁（男）", "Yuki-Onna's Hug (M)"],
    ["魔犬の姦淫（発動）", "Evil Dog's Adultery (Init)"],
    ["魔犬の姦淫（継続）", "Evil Dog's Adultery (Cont)"],
    ["魔王の夜伽（発動）", "Monster Lord's All-Night Vigil (Init)"],
    ["魔王の夜伽（継続）", "Monster Lord's All-Night Vigil (Cont)"],
    ["魔花の搾檻（女）", "Flower Prison (F)"],
    ["魔花の搾檻（発動）", "Flower Prison (Init)"],
    ["魔花の搾檻（継続）", "Flower Prison (Cont)"],
    ["麻痺おしゃぶり（女）", "Paralysis Pacifier (F)"],
    ["麻痺おしゃぶり（男）", "Paralysis Pacifier (M)"],
  ]

  ILLUSTRATOR_NAME = [
    ["人外モドキ", "Jingai Modoki"],
    ["あかざわRED", "Akazawa RED"],
    ["瀬戸内", "Setouchi"],
    ["健康クロス", "Kenkou Cross"],
    ["アレキシ", "Arekishi"],
    ["海の山", "Uminoyama"],
    ["ネコまんま", "Neko Manma"],
    ["すがもん", "SugaMon"],
    ["いろどり", "Irodori"],
    ["日下部", "kusakabe"],
    ["デルフィナス", "Delphinus"],
    ["鰯の頭", "Iwashi no Atama"],
    ["シルク", "Silk"],
    ["クール教信者", "Cool-Kyou Shinja"],
    ["ステルス改行", "Stealth Changing Line"],
    ["しぃずぴぃ", "Shimpi"],
    ["雪村信二", "Yukimura Shinji"],
    ["磊磊ちかさ", "rai-rai chika sa"],
    ["とーます", "Thomas"],
    ["真喜屋", "makiya"],
    ["しき", "Shiki"],
    ["えぺ", "Epée"],
    ["RPGツクール", "RPG Maker"],
  ]

  #Custom Special Sale Notes
  SPECIAL_SALE = [
                [1, "非売品を素材にしていますが、本当に売却しますか？", "Synthesis result, base item not sold anywhere, confirm sale?"],
                [2, "非売品ですが、本当に売却しますか？", "Item not sold anywhere, confirm sale?"],
                [3, "非売品かつ合成の素材になりますが、本当に売却しますか？", "Synthesis material, not sold anywhere, confirm sale?"],
                [4, "合成の素材になりますが、本当に売却しますか？", "Synthesis material, confirm sale?"],
                [5, "ちぃぱっぱはいらないよ……", "A Chi Pa Pa! I do not need that..."],
  ]
  
  # * New Method: SToggle Between Ranks and Percents
  def self.toggle_rank(use_percent = false)
    if !use_percent
      new_valuation = ["S","A","B","C","D","E"]
      new_status_valuation = [
          [130,120,110,100, 90], # MAXHP
          [130,120,110,100, 90], # MAXMP
          [ 30, 20, 10,  0,-20], # MAXSP
          [130,120,110,100, 90], # 攻撃力
          [130,120,110,100, 90], # 防御力
          [130,120,110,100, 90], # 魔法力
          [130,120,110,100, 90], # 魔法防御
          [130,120,110,100, 90], # 敏捷性
          [130,120,110,100, 90], # 運
        ]
    else
        new_valuation = ["500%","495%","490%","485%","480%","475%","470%","465%","460%","455%","450%","445%","440%","435%","430%","425%","420%","415%","410%","405%","400%","395%","390%","385%","380%","375%","370%","365%","360%","355%","350%","345%","340%","335%","330%","325%","320%","315%","310%","305%","300%","295%","290%","285%","280%","275%","270%","265%","260%","255%","250%","245%","240%","235%","230%","225%","220%","215%","210%","205%","200%","195%","190%","185%","180%","175%","170%","165%","160%","155%","150%","145%","140%","135%","130%","125%","120%","115%","110%","105%","100%"," 95%"," 90%"," 85%"," 80%"," 75%"," 70%"," 65%"," 60%"," 55%"," 50%"," 45%"," 40%"," 35%"," 30%"," 25%"," 20%"," 15%"," 10%","  5%"]
        new_status_valuation = [
            [500,495,490,485,480,475,470,465,460,455,450,445,440,435,430,425,420,415,410,405,400,395,390,385,380,375,370,365,360,355,350,345,340,335,330,325,320,315,310,305,300,295,290,285,280,275,270,265,260,255,250,245,240,235,230,225,220,215,210,205,200,195,190,185,180,175,170,165,160,155,150,145,140,135,130,125,120,115,110,105,100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10,  5], # MAXHP
            [500,495,490,485,480,475,470,465,460,455,450,445,440,435,430,425,420,415,410,405,400,395,390,385,380,375,370,365,360,355,350,345,340,335,330,325,320,315,310,305,300,295,290,285,280,275,270,265,260,255,250,245,240,235,230,225,220,215,210,205,200,195,190,185,180,175,170,165,160,155,150,145,140,135,130,125,120,115,110,105,100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10,  5], # MAXMP
            [400,395,390,385,380,375,370,365,360,355,350,345,340,335,330,325,320,315,310,305,300,295,290,285,280,275,270,265,260,255,250,245,240,235,230,225,220,215,210,205,200,195,190,185,180,175,170,165,160,155,150,145,140,135,130,125,120,115,110,105,100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10,  5,  0, -5,-10,-15,-20,-25,-30,-35,-40,-45,-50,-55,-60,-65,-70,-75,-80,-85,-90,-95], # MAXSP
            [500,495,490,485,480,475,470,465,460,455,450,445,440,435,430,425,420,415,410,405,400,395,390,385,380,375,370,365,360,355,350,345,340,335,330,325,320,315,310,305,300,295,290,285,280,275,270,265,260,255,250,245,240,235,230,225,220,215,210,205,200,195,190,185,180,175,170,165,160,155,150,145,140,135,130,125,120,115,110,105,100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10,  5], # 攻撃力
            [500,495,490,485,480,475,470,465,460,455,450,445,440,435,430,425,420,415,410,405,400,395,390,385,380,375,370,365,360,355,350,345,340,335,330,325,320,315,310,305,300,295,290,285,280,275,270,265,260,255,250,245,240,235,230,225,220,215,210,205,200,195,190,185,180,175,170,165,160,155,150,145,140,135,130,125,120,115,110,105,100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10,  5], # 防御力
            [500,495,490,485,480,475,470,465,460,455,450,445,440,435,430,425,420,415,410,405,400,395,390,385,380,375,370,365,360,355,350,345,340,335,330,325,320,315,310,305,300,295,290,285,280,275,270,265,260,255,250,245,240,235,230,225,220,215,210,205,200,195,190,185,180,175,170,165,160,155,150,145,140,135,130,125,120,115,110,105,100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10,  5], # 魔法力
            [500,495,490,485,480,475,470,465,460,455,450,445,440,435,430,425,420,415,410,405,400,395,390,385,380,375,370,365,360,355,350,345,340,335,330,325,320,315,310,305,300,295,290,285,280,275,270,265,260,255,250,245,240,235,230,225,220,215,210,205,200,195,190,185,180,175,170,165,160,155,150,145,140,135,130,125,120,115,110,105,100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10,  5], # 魔法防御
            [500,495,490,485,480,475,470,465,460,455,450,445,440,435,430,425,420,415,410,405,400,395,390,385,380,375,370,365,360,355,350,345,340,335,330,325,320,315,310,305,300,295,290,285,280,275,270,265,260,255,250,245,240,235,230,225,220,215,210,205,200,195,190,185,180,175,170,165,160,155,150,145,140,135,130,125,120,115,110,105,100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10,  5], # 敏捷性
            [500,495,490,485,480,475,470,465,460,455,450,445,440,435,430,425,420,415,410,405,400,395,390,385,380,375,370,365,360,355,350,345,340,335,330,325,320,315,310,305,300,295,290,285,280,275,270,265,260,255,250,245,240,235,230,225,220,215,210,205,200,195,190,185,180,175,170,165,160,155,150,145,140,135,130,125,120,115,110,105,100, 95, 90, 85, 80, 75, 70, 65, 60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10,  5], # 運
          ]
    end
    
    NWConst::JobChange.send(:remove_const , :VALUATION) if NWConst::Casino.const_defined?(:VALUATION)
    NWConst::JobChange.const_set(:VALUATION, new_valuation) 
      
    NWConst::JobChange.send(:remove_const , :STATUS_VALUATION) if NWConst::Casino.const_defined?(:VALUATION)
    NWConst::JobChange.const_set(:STATUS_VALUATION, new_status_valuation) 
  end
  
end
#==============================================================================
#From Script: ベース/DataObject
#Overwrite lib_category AND lib_name
#This Allows Searching The Above Arrays And Replacing Data
#==============================================================================
#==============================================================================
# ■ RPG::Actor
#==============================================================================
class RPG::Actor < RPG::BaseItem
  #--------------------------------------------------------------------------
  # ● イラストレーター名
	
  #--------------------------------------------------------------------------

  def illustrator_name

    if @data_ex.key?(:illustrator_name)
        illustrator_name = @data_ex[:illustrator_name].to_s
        NWConst::Library::ILLUSTRATOR_NAME.each{|jap_name, tran_name| 
          if jap_name == illustrator_name
            illustrator_name = tran_name
            break
          end
        }
        return illustrator_name
    else
      return self.name
    end
    return @data_ex.key?(:illustrator_name) ? @data_ex[:illustrator_name] : ""
  end
end

#==============================================================================
# ■ RPG::Enemy
#==============================================================================
class RPG::Enemy < RPG::BaseItem
  #--------------------------------------------------------------------------
  # ● 図鑑種族名
  #--------------------------------------------------------------------------
  def lib_category
    if @data_ex.key?(:lib_category)
        category_name = @data_ex[:lib_category].to_s
        NWConst::Library::RACE_SPECIAL_NAME.each{|jap_name, tran_name| 
          if jap_name == category_name
            category_name = tran_name
            break
          end
        }
        return category_name
    else
      return :EMPTY
    end
    #return @data_ex.key?(:lib_category) ? @data_ex[:lib_category] : :EMPTY
  end  
  #--------------------------------------------------------------------------
  # ● 図鑑名称
  #--------------------------------------------------------------------------
  def lib_name
    if @data_ex.key?(:lib_name)
        enemy_name = @data_ex[:lib_name].to_s
        NWConst::Library::ENEMY_SPECIAL_NAME.each{|jap_name, tran_name| 
          if jap_name == enemy_name
            enemy_name = tran_name
            break
          end
        }
        return enemy_name
    else
      return self.name
    end
    #return @data_ex.key?(:lib_name) ? @data_ex[:lib_name] : self.name
  end
end

#==============================================================================
# ■ RPG::Skill
#==============================================================================
class RPG::Skill < RPG::UsableItem
  #--------------------------------------------------------------------------
  # ● 図鑑名称
  #--------------------------------------------------------------------------
  def lib_name
    if @data_ex.key?(:lib_name)
        skill_name = @data_ex[:lib_name].to_s
        NWConst::Library::SKILL_SPECIAL_NAME.each{|jap_name, tran_name| 
          if jap_name == skill_name
            skill_name = tran_name
            break
          end
        }
        return skill_name
    else
      return self.name
    end
    #return @data_ex.key?(:lib_name) ? @data_ex[:lib_name] : self.name
  end
end

#==============================================================================
# ■ Game_Library
#----------------------------------------------------------------------------
# 図鑑に関するデータを管理します。
#==============================================================================
class Game_Library
  #--------------------------------------------------------------------------
  # ● 場所フラグのチェック
  #--------------------------------------------------------------------------
  def place_name?(place)
    if place?(place)
      place_name = place.to_s
        NWConst::Library::PLACE_NAME.each{|jap_name, tran_name| 
          if jap_name == place_name
            place_name = tran_name
            break
          end
        }
        return place_name
    else
      place_name = "?" * 8
    end
      
    return place_name
  end
end

#==============================================================================
# ■ RPG::BaseItem
#==============================================================================
class RPG::BaseItem
  #--------------------------------------------------------------------------
  # ● Special Sale                    特殊売却
  #--------------------------------------------------------------------------
  def selld_draw
    if @data_ex.key?(:selld_draw)
        sale_text = @data_ex[:selld_draw]
        NWConst::Library::SPECIAL_SALE.each{|index, jap_text, tran_text| 
          if jap_text == sale_text
            sale_text = tran_text
            break
          end
        }
        return sale_text
    else
      return nil
    end
    #return @data_ex.key?(:selld_draw) ? @data_ex[:selld_draw] : nil
  end
end

#Overwrite Script:  図鑑/本体
#==============================================================================
# ■ Window_Library_RightMain
#==============================================================================
class Window_Library_RightMain < Window_Selectable
  #--------------------------------------------------------------------------
  # ● キャラ説明描画(アクター, エネミー)
  #--------------------------------------------------------------------------
  def draw_chara_description(y, chara)
    # 描画域の生成
    rect = standard_rect(y)
    rect.height = self.contents.height - rect.y
    @dest_rect = rect
    @src_rect.y = 0 if @last_ext != @ext
    # 解説文章の取得
    desc = ["No Details"]
    if chara.is_a?(RPG::Enemy)
      key = chara.id
      desc = ENEMY_DESCRIPTION[key] if ENEMY_DESCRIPTION.key?(key)
    end

    # Generating a bit map of commentary text (key to the cacheext)
    if @description[@ext].nil? || @description[@ext].disposed?
      @description[@ext] = Bitmap.new(rect.width, desc.size * line_height)
      @src_rect = @description[@ext].rect
      i = 0
#=begin
      #Add WordWrap For English Text
        str = ""
        #Get Description From Array To String
        desc.each{|txt|
          if txt == ""
            str = str + "\n\n"
          else
            str = str + txt + " "
          end
        }
        #Process Actor
        if chara.is_a?(RPG::Actor)
          desc = []
          #Change String To Line Array
          str2 = str.split("\n")
          str = ""
          str2.each{|s|
            #If Line Blank Retain Else Reformat Line
            if s == ""
                str = str + "\n\n"
            else
                str = str + reformat_wrapped(s)
            end
          }
          str2 = ""
          #Take Reformatted Description And Overwrite Old
          str2 = str.split("\n")
          str2.each{|s|
            if s == ""
                desc<<""
            else
                desc<<s
            end
          }
        
        #Process Enemy
        if chara.is_a?(RPG::Enemy)
          desc = []
          #Change String To Line Array
          str2 = str.split("\n")
          str = ""
          str2.each{|s|
            #If Line Blank Retain Else Reformat Line
            if s == ""
                str = str + "\n\n"
            else
                str = str + reformat_wrapped(s)
            end
            }
          str2 = ""
          #Take Reformatted Description And Overwrite Old
          str2 = str.split("\n")
          #File.open("Library/Enemy.txt", "a") { |f|
          #  f.write("<<enemy_description/"+key.to_s+"/note>>"+"\n")
            str2.each{|s|
              if s == ""
                  desc<<""
          #        f.write("\n")
              else
                  desc<<s
          #        f.write(s + "\n")
              end
              }
          #  f.write("\n")
          #}
      end
      
      #Recalculate Dimensions Of Content
      @description[@ext] = Bitmap.new(rect.width, desc.size * line_height)
      @src_rect = @description[@ext].rect
end

      desc.each{|txt|
        r = standard_rect(i * line_height)
        @description[@ext].draw_text(r, txt)
        i += 1
      }
    end
    bmp = @description[@ext]
    # ビットマップの範囲を設定
    @src_rect.height = bmp.height - @src_rect.y
    # 解説文章を描画域へ転送する。
    self.contents.blt(@dest_rect.x, @dest_rect.y, bmp, @src_rect)
    # スクロールカーソルを転送する。
    # 上
    if @src_rect.y > 0 && bmp.height > @dest_rect.height
      arrow_rect = Rect.new(88, 14, 14, 10)
      self.contents.blt((self.contents.width - 14) / 2, rect.y - 10,
        self.windowskin, arrow_rect)
    end
    # 下
    if @src_rect.height > @dest_rect.height
      arrow_rect = Rect.new(88, 38, 14, 10)
      self.contents.blt((self.contents.width - 14) / 2, rect.y + rect.height - 10,
        self.windowskin, arrow_rect)
    end
    # 戻る
    reset_font_settings
    return rect.y + rect.height
  end
  
  #--------------------------------------------------------------------------
  # ● 自動改行テキスト表示
  #--------------------------------------------------------------------------
  def draw_text_auto_line(rect, text)
    array = []
    s = ""    
    #text.size.times{|i|
    #  s += text[i]
    #  next unless self.contents.width < text_size(s).width + (standard_padding * 2)
    #  array.push(s)
    #  s = ""
    #}
    #s = reformat_wrapped(text) #.split("\n")
    #array.push(s)
    s = reformat_wrapped(text).split("\n")
    s.each{|str| array.push(str)}
    #array.push(reformat_wrapped(text).split("\n"))
    array.each{|str| draw_text(rect, str); rect.y += rect.height}
    return rect
  end
  
  #--------------------------------------------------------------------------
  # ● 自動改行テキスト表示　配列の区切りで改行
  #--------------------------------------------------------------------------
  def draw_text_auto_line_ex(rect, text)
    array = []
    s = ""
    #text.size.times{|i|
    #  s += text[i] if text[i] != "\n"
    #  next if text[i] != "\n" and
    #          self.contents.width >= text_size(s).width + (standard_padding * 2)
    #  array.push(s)
    #  s = ""
    #}
    s = reformat_wrapped(text).split("\n")
    s.each{|str| array.push(str)}
    array.each{|str| draw_text(rect, str); rect.y += rect.height}
    return rect
  end
  
  def reformat_wrapped(s, width=35)
    lines = []
    line = ""
    s.split(/\s+/).each do |word|
      if line.size + word.size >= width
        lines << line
        line = word
      elsif line.empty?
       line = word
      else
       line << " " << word
     end
     end
     lines << line if line
    return lines.join "\n"
  end
  
  #--------------------------------------------------------------------------
  # ● Unique Actor Abilities
  #--------------------------------------------------------------------------
  def draw_actor_fix_ability(y, actor)
    fix_abilities = ACTOR_FIX_ABILITY[actor.id]
    return y unless fix_abilities
    rect = standard_rect(y)
    reset_font_settings
    
    change_color(system_color)
    draw_text(rect, FIX_ABILITY_NAME)
    rect.y += rect.height
    change_color(special_color)
    draw_text(rect, fix_abilities.first)
    rect.y += rect.height
    change_color(normal_color)
    
    all_text = ""
    fix_abilities[1...fix_abilities.size].each{|fix_ability|
      all_text += fix_ability + " "
      #all_text += "。" unless all_text[-1] == "。"
      #all_text += "\n"
    }
    #all_text = reformat_wrapped(all_text)
    all_text.slice!(-1, 1)
    rect = draw_text_auto_line_ex(rect, all_text)
    return rect.y
  end
  
  #--------------------------------------------------------------------------
  # ● Draw Common Parts (Weapons, Armor, Accessories, Items)
  #--------------------------------------------------------------------------
  def draw_items_common(item)
    rect = standard_rect
    reset_font_settings
    # アイテム名の描画
    draw_item_name(item, rect.x, rect.y)
    rect.y = self.contents.height - (line_height * 6) # Original 5
    
    # 解説の描画
    change_color(system_color)
    draw_text(rect, "Details")
    rect.y += rect.height
    change_color(normal_color)
    all_text = ""
    item.description.each_line do |d|
      d.slice!(/\[(.*?)\]/)
      d.chomp!
      d.gsub!("\\C[0]","")
      d.gsub!("\\C[1]","")
      d.gsub!("\\C[6]","")
      d.gsub!("\\C[8]","")
      d.gsub!("\\C[10]","")
      d.gsub!("\\C[21]","")
      next if d == ""
      all_text += d
      all_text += "\n"
    end
    rect = draw_text_auto_line_ex(rect, all_text)
    
    return line_height + LINE_HEIGHT
  end
end



#==============================================================================
# ■ Game_Actor
#==============================================================================
class Game_Actor < Game_Battler
#--------------------------------------------------------------------------
  # ○ レベルアップメッセージの表示
  #     new_skills : 新しく習得したスキルの配列
  #--------------------------------------------------------------------------
  def display_level_up(new_skills, kind)
    $game_message.new_page
    case kind
      when :base;  prefix = Vocab::level
      when :class; prefix = self.class.name + ' level'
      when :tribe; prefix = self.tribe.name + ' level'
    end

    @name = actor.name if @name == nil
    $game_message.add(sprintf(Vocab::LevelUp, @name, prefix, @level[kind]))
    new_skills.each { |skill|
      # ひきも記の「メッセージ制御文字拡張」競合対策
      $game_message.add(sprintf(Vocab::ObtainSkill, "\\S[#{skill.id}]"))
    }
  end
end

#==============================================================================
# ■ Scene_Ability
#==============================================================================
class Scene_Ability < Scene_MenuBase
  #--------------------------------------------------------------------------
  # ● Start Screen/Ability Editor Edit 518
  #--------------------------------------------------------------------------
  alias :ex_alt_start :start
  def start
    ex_alt_start
    # Add Correction For Height & Alignment
    correction
  end
  
  #--------------------------------------------------------------------------
  # ● Corrects Height & Alignment
  #--------------------------------------------------------------------------
  def correction
    #Help Window + Ability Window
    top_area = @help_window.height + @ability_type_window.height
    #Help Window X Lines
    #Ability Window Align To Help Window
    @ability_type_window.y = @help_window.height
    # Align Middle Windows To Ability Window
    @equip_ability_window.y = top_area
    @stand_ability_window.y = top_area
    #Shrink Middle Windows To Fit Between Second & Bottom
    @stand_ability_window.height = Graphics.height - (top_area + @key_help_window.height)
    @equip_ability_window.height = Graphics.height - (top_area + @key_help_window.height)
  end
  
  #--------------------------------------------------------------------------
  # ● Create Alternate Ability Help Window
  #--------------------------------------------------------------------------
  def create_ability_help_window
    @help_window = Window_Help_Color.new(3)
    @help_window.viewport = @viewport
  end
end

class Window_Help < Window_Base
  #--------------------------------------------------------------------------
  # * Object Initialization
  #--------------------------------------------------------------------------
  def initialize(line_number = 4)
    super(0, 0, Graphics.width, fitting_height(line_number))
  end
end

#==============================================================================
# ■ Foo::PTEdit::Window_SortEval
#==============================================================================
class Foo::PTEdit::Window_SortEval < Window_Base
  #--------------------------------------------------------------------------
  # ● Display Sorting Method (New)
  #--------------------------------------------------------------------------
  def draw_eval
    texts = {
      :id => "ID Order",
      :name => "By Name"
    }
    
    if texts.include?(eval)
      text = texts[eval]
    else
      # Added To Translate Categories
      text = eval.to_s
      NWConst::Library::RACE_SPECIAL_NAME.each{|jap_name, tran_name| 
        if jap_name.to_s == text.to_s
          text = tran_name
          break
        end
      }
    end
    
    change_color(system_color)
    rect = Rect.new(0,0,self.contents.width,line_height)
    draw_text(rect, text, 1)
  end
end

#==============================================================================
# ■ Foo::JobChange::Window_SortEval
#==============================================================================
class Foo::JobChange::Window_SortEval < Window_Base
  #--------------------------------------------------------------------------
  # ● Display Sorting Method (New)
  #--------------------------------------------------------------------------
  def draw_eval
    texts = {
      :id => "ID Order",
      :name => "By Name"
    }
    
    if texts.include?(eval)
      text = texts[eval]
    else
      # Added To Translate Categories
      text = eval.to_s
      NWConst::Library::RACE_SPECIAL_NAME.each{|jap_name, tran_name| 
        if jap_name.to_s == text.to_s
          text = tran_name
          break
        end
      }
    end
    
    change_color(system_color)
    rect = Rect.new(0,0,self.contents.width,line_height)
    draw_text(rect, text, 1)
  end
end

#==============================================================================
# ■ DataManager
#==============================================================================
class << DataManager
  
  #--------------------------------------------------------------------------
  # ● Load Normal Database EX
  #--------------------------------------------------------------------------
  alias dargoth_load_normal_database_ex load_normal_database_ex
  def load_normal_database_ex
    dargoth_load_normal_database_ex
    # Added To Adjust Resolution From Game.ini
    # Requires Basic Window Resizer v1.1
  end
  
  #--------------------------------------------------------------------------
  # ○ Load Normal Database
  #--------------------------------------------------------------------------
  alias dargoth_load_normal_database load_normal_database
  def load_normal_database
    dargoth_load_normal_database
    # Added To Adjust Resolution From Game.ini
    # Requires Basic Window Resizer v1.1
  end
end

#==============================================================================
# ■ DataManager
#==============================================================================
module DataManager
  #--------------------------------------------------------------------------
  # ● Start Load Of Saved Game
  #--------------------------------------------------------------------------
  def self.load_game(index)
    begin
      load_game_without_rescue(index) #rescue false
    rescue Exception => ex_error
      MessageBox.fatalerror(ex_error) if NWConst::Library::ENABLE_SAVE_DEBUG
      return false
    end
  end
end


#==============================================================================
# 
# ▼ Yanfly Engine Ace - Ace Message System v1.05
# -- Last Updated: 2012.01.13
# -- Level: Normal
# -- Requires: n/a
# 
#==============================================================================

$imported = {} if $imported.nil?
$imported["YEA-MessageSystem"] = true

#==============================================================================
# ▼ Updates
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# 2015.08.10 - Unofficial Update For Paradox 1.21
# 2012.07.21 - Fixed REGEXP error at line 824
# 2012.01.13 - Bug Fixed: Negative tags didn't display other party members.
# 2012.01.12 - Compatibility Update: Message Actor Codes
# 2012.01.10 - Added Feature: \pic[x] text code.
# 2012.01.04 - Bug Fixed: \ic tag was \ii. No longer the case.
#            - Added: Scroll Text window now uses message window font.
# 2011.12.31 - Started Script and Finished.
# 
#==============================================================================
# ▼ Introduction
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# While RPG Maker VX Ace certainly improved the message system a whole lot, it
# wouldn't hurt to add in a few more features, such as name windows, converting
# textcodes to write out the icons and/or names of items, weapons, armours, and
# more in quicker fashion. This script also gives the developer the ability to
# adjust the size of the message window during the game, give it a separate
# font, and to give the player a text fast-forward feature.
# 
#==============================================================================
# ▼ Instructions
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# To install this script, open up your script editor and copy/paste this script
# to an open slot below ▼ Materials/素材 but above ▼ Main. Remember to save.
# 
# -----------------------------------------------------------------------------
# Message Window text Codes - These go inside of your message window.
# -----------------------------------------------------------------------------
#  Default:    Effect:
#    \v[x]     - Writes variable x's value.
#    \n[x]     - Writes actor x's name.
#    \p[x]     - Writes party member x's name.
#    \g        - Writes gold currency name.
#    \c[x]     - Changes the colour of the text to x.
#    \i[x]     - Draws icon x at position of the text.
#    \{        - Makes text bigger by 8 points.
#    \}        - Makes text smaller by 8 points.
#    \$        - Opens gold window.
#    \.        - Waits 15 frames (quarter second).
#    \|        - Waits 60 frames (a full second).
#    \!        - Waits until key is pressed.
#    \>        - Following text is instant.
#    \<        - Following text is no longer instant.
#    \^        - Skips to the next message.
#    \\        - Writes a "\" in the window.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Wait:       Effect:
#    \w[x]     - Waits x frames (60 frames = 1 second). Message window only.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  NameWindow: Effect:
#    \n<x>     - Creates a name box with x string. Left side. *Note
#    \nc<x>    - Creates a name box with x string. Centered. *Note
#    \nr<x>    - Creates a name box with x string. Right side. *Note
# 
#              *Note: Works for message window only.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Position:   Effect:
#    \px[x]    - Sets x position of text to x.
#    \py[x]    - Sets y position of text to y.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Picture:    Effect:
#    \pic[x]   - Draws picture x from the Graphics\Pictures folder.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Outline:    Effect:
#    \oc[x]    - Sets outline colour to x.
#    \oo[x]    - Sets outline opacity to x.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Font:       Effect:
#    \fr       - Resets all font changes.
#    \fz[x]    - Changes font size to x.
#    \fn[x]    - Changes font name to x.
#    \fb       - Toggles font boldness.
#    \fi       - Toggles font italic.
#    \fo       - Toggles font outline.
#    \fs       - Toggles font shadow.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Actor:      Effect:
#    \af[x]    - Shows face of actor x. *Note
#    \ac[x]    - Writes out actor's class name. *Note
#    \as[x]    - Writes out actor's subclass name. Req: Class System. *Note
#    \an[x]    - Writes out actor's nickname. *Note
# 
#              *Note: If x is 0 or negative, it will show the respective
#               party member's face instead.
#                   0 - Party Leader
#                  -1 - 1st non-leader member.
#                  -2 - 2nd non-leader member. So on.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Salvaged From ATS: Special Message Codes [VXA] by modern algebra (rmrk.net)
#
#  Enemy:      Effect:
#    \en[x]    - Writes out enemy's name.
#
#  Party:      Effect:
#    \pg       - Draws the amount of money the party has.
#    \g        - Draws the unit of currency.
#
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Names:      Effect:
#    \nc[x]    - Writes out class x's name.
#    \ni[x]    - Writes out item x's name.
#    \nw[x]    - Writes out weapon x's name.
#    \na[x]    - Writes out armour x's name.
#    \ns[x]    - Writes out skill x's name.
#    \nt[x]    - Writes out state x's name.
#    \ne[x]    - Writes out element x's name.
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
#  Icon Names: Effect:
#    \ic[x]    - Writes out class x's name including icon. *
#    \ii[x]    - Writes out item x's name including icon.
#    \iw[x]    - Writes out weapon x's name including icon.
#    \ia[x]    - Writes out armour x's name including icon.
#    \is[x]    - Writes out skill x's name including icon.
#    \it[x]    - Writes out state x's name or icon.
#    \ie[x]    - Writes out element x's name or icon.
# 
#              *Note: Requires YEA - Class System
# 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# 
# And those are the text codes added with this script. Keep in mind that some
# of these text codes only work for the Message Window. Otherwise, they'll work
# for help descriptions, actor biographies, and others.
# 
#==============================================================================
# ▼ Compatibility
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# This script is made strictly for RPG Maker VX Ace. It is highly unlikely that
# it will run with RPG Maker VX without adjusting.
# 
#==============================================================================

module YEA
  module MESSAGE
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - General Message Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # The following below will adjust the basic settings and that will affect
    # the majority of the script. Adjust them as you see fit.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This button is the button used to make message windows instantly skip
    # forward. Hold down for the effect. Note that when held down, this will
    # speed up the messages, but still wait for the pauses. However, it will
    # automatically go to the next page when prompted.
    #Disabled for Paradox, A on keyboard works for this.
    #TEXT_SKIP = :A     # Input::A is the shift button on keyboard.
    
    # This variable adjusts the number of visible rows shown in the message
    # window. If you do not wish to use this feature, set this constant to 0.
    # If the row value is 0 or below, it will automatically default to 4 rows.
    VARIABLE_ROWS  = 0
    
    # This variable adjusts the width of the message window shown. If you do
    # not wish to use this feature, set this constant to 0. If the width value
    # is 0 or below, it will automatically default to the screen width.
    VARIABLE_WIDTH = 0
    
    # This is the amount of space that the message window will indent whenever
    # a face is used. Default: 112
    FACE_INDENT_X = 112
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Name Window Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # The name window is a window that appears outside of the main message
    # window box to display whatever text is placed inside of it like a name.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    NAME_WINDOW_X_BUFFER = 0       # Buffer x position of the name window.
    NAME_WINDOW_Y_BUFFER = 0       # Buffer y position of the name window.
    NAME_WINDOW_PADDING  = 20      # Padding added to the horizontal position.
    NAME_WINDOW_OPACITY  = 255     # Opacity of the name window.
    NAME_WINDOW_COLOUR   = 0       # Text colour used by default for names.
    
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # - Message Font Settings -
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # Ace Message System separates the in-game system font form the message
    # font. Adjust the settings here for your fonts.
    #=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    # This array constant determines the fonts used. If the first font does not
    # exist on the player's computer, the next font in question will be used
    # in place instead and so on.
    MESSAGE_WINDOW_FONT_NAME = ["VL Gothic", "VL Gothic Regular", "Courier New"]
    
    # These adjust the other settings regarding the way the game font appears
    # including the font size, whether or not the font is bolded by default,
    # italic by default, etc.
    MESSAGE_WINDOW_FONT_SIZE    = 24       # Font size.
    MESSAGE_WINDOW_FONT_BOLD    = false    # Default bold?
    MESSAGE_WINDOW_FONT_ITALIC  = false    # Default italic?
    MESSAGE_WINDOW_FONT_OUTLINE = true     # Default outline?
    MESSAGE_WINDOW_FONT_SHADOW  = false    # Default shadow?
    
  end # MESSAGE
end # YEA

#==============================================================================
# ▼ Editing anything past this point may potentially result in causing
# computer damage, incontinence, explosion of user's head, coma, death, and/or
# halitosis so edit at your own risk.
#==============================================================================

#==============================================================================
# ■ Variable
#==============================================================================

module Variable
  
  #--------------------------------------------------------------------------
  # self.message_rows
  #--------------------------------------------------------------------------
  def self.message_rows
    return 4 if YEA::MESSAGE::VARIABLE_ROWS <= 0
    return 4 if $game_variables[YEA::MESSAGE::VARIABLE_ROWS] <= 0
    return $game_variables[YEA::MESSAGE::VARIABLE_ROWS]
  end
  
  #--------------------------------------------------------------------------
  # self.message_width
  #--------------------------------------------------------------------------
  def self.message_width
    return Graphics.width if YEA::MESSAGE::VARIABLE_WIDTH <= 0
    return Graphics.width if $game_variables[YEA::MESSAGE::VARIABLE_WIDTH] <= 0
    return $game_variables[YEA::MESSAGE::VARIABLE_WIDTH]
  end
  
end # Variable

#==============================================================================
# ■ Game_Interpreter
#==============================================================================

class Game_Interpreter
  
  #--------------------------------------------------------------------------
  # overwrite method: command_101
  # Updated for Paradox
  #--------------------------------------------------------------------------
  def command_101
    wait_for_message
    $game_message.face_name = @params[0]
    $game_message.face_index = @params[1]
    $game_message.background = @params[2]
    $game_message.position = @params[3]
    while continue_message_string?
      @index += 1
      if @list[@index].code == 401
        $game_message.add(@list[@index].parameters[0])
      end
      break if $game_message.texts.size >= Variable.message_rows
    end
    case next_event_code
    when 102
      @index += 1
      setup_choices(@list[@index].parameters)
    when 103
      @index += 1
      setup_num_input(@list[@index].parameters)
    when 104
      @index += 1
      setup_item_choice(@list[@index].parameters)
    when 355
      while next_command_ex_choice?
        @index += 1
        command_355
      end
    end
    wait_for_message
  end
  
  #--------------------------------------------------------------------------
  # new method: continue_message_string?
  #--------------------------------------------------------------------------
  def continue_message_string?
    return true if next_event_code == 101 && Variable.message_rows > 4
    return next_event_code == 401
  end
  
end # Game_Interpreter

#==============================================================================
# ■ Window_Base
#==============================================================================

class Window_Base < Window
  
  #--------------------------------------------------------------------------
  # new method: setup_message_font
  #--------------------------------------------------------------------------
  def setup_message_font
    @message_font = true
    change_color(normal_color)
    contents.font.out_color = Font.default_out_color
    contents.font.name = YEA::MESSAGE::MESSAGE_WINDOW_FONT_NAME
    contents.font.size = YEA::MESSAGE::MESSAGE_WINDOW_FONT_SIZE
    contents.font.bold = YEA::MESSAGE::MESSAGE_WINDOW_FONT_BOLD
    contents.font.italic = YEA::MESSAGE::MESSAGE_WINDOW_FONT_ITALIC
    contents.font.outline = YEA::MESSAGE::MESSAGE_WINDOW_FONT_OUTLINE
    contents.font.shadow = YEA::MESSAGE::MESSAGE_WINDOW_FONT_SHADOW
  end
  
  #--------------------------------------------------------------------------
  # alias method: reset_font_settings
  #--------------------------------------------------------------------------
  alias window_base_reset_font_settings_ams reset_font_settings
  def reset_font_settings
    if @message_font
      setup_message_font
    else
      window_base_reset_font_settings_ams
      contents.font.out_color = Font.default_out_color
      contents.font.outline = Font.default_outline
      contents.font.shadow = Font.default_shadow
    end
  end
  
  #--------------------------------------------------------------------------
  # alias method: convert_escape_characters
  #--------------------------------------------------------------------------
  alias window_base_convert_escape_characters_ams convert_escape_characters
  def convert_escape_characters(text)
    result = text
    result = window_base_convert_escape_characters_ams(result)
    result = convert_ace_message_system_new_escape_characters(result)
    return result
  end
  
  #--------------------------------------------------------------------------
  # new method: convert_ace_message_system_new_escape_characters
  # Updated for Paradox
  #--------------------------------------------------------------------------
  def convert_ace_message_system_new_escape_characters(result)
    #msgbox result
    #---
    #result.gsub!(/\edialogue\[([^\]]+)\]/) { LanguageFileSystem::get_dialogue($1.to_s) }
    #---
    result.gsub!(/\eFR/i) { "\eAMSF[0]" }
    result.gsub!(/\eFB/i) { "\eAMSF[1]" }
    result.gsub!(/\eFI/i) { "\eAMSF[2]" }
    result.gsub!(/\eFO/i) { "\eAMSF[3]" }
    result.gsub!(/\eFS/i) { "\eAMSF[4]" }
    #---
    result.gsub!(/\eAC\[([-+]?\d+)\]/i) { escape_actor_class_name($1.to_i) }
    result.gsub!(/\eAS\[([-+]?\d+)\]/i) { escape_actor_subclass_name($1.to_i) }
    result.gsub!(/\eAN\[([-+]?\d+)\]/i) { escape_actor_nickname($1.to_i) }
    #---
    result.gsub!(/\eNC\[(\d+)\]/i) { $data_classes[$1.to_i].name rescue "" }
    result.gsub!(/\eNI\[(\d+)\]/i) { $data_items[$1.to_i].name rescue "" }
    result.gsub!(/\eNW\[(\d+)\]/i) { $data_weapons[$1.to_i].name rescue "" }
    result.gsub!(/\eNA\[(\d+)\]/i) { $data_armors[$1.to_i].name rescue "" }
    result.gsub!(/\eNS\[(\d+)\]/i) { $data_skills[$1.to_i].name rescue "" }
    result.gsub!(/\eNT\[(\d+)\]/i) { $data_states[$1.to_i].name rescue "" }
    result.gsub!(/\eNE\[(\d+)\]/i)  { $data_system.elements[$1.to_i].to_s rescue ""  }
    #---
    result.gsub!(/\eEN\[(\d+)\]/i)  { $data_enemies[$1.to_i].name rescue "" }
    result.gsub!(/\ePG/i) { $game_party.gold }
    #---
    result.gsub!(/\eIC\[(\d+)\]/i) { escape_icon_item($1.to_i, :class) }
    result.gsub!(/\eII\[(\d+)\]/i) { escape_icon_item($1.to_i, :item) }
    result.gsub!(/\eIW\[(\d+)\]/i) { escape_icon_item($1.to_i, :weapon) }
    result.gsub!(/\eIA\[(\d+)\]/i) { escape_icon_item($1.to_i, :armour) }
    result.gsub!(/\eIS\[(\d+)\]/i) { escape_icon_item($1.to_i, :skill) }
    result.gsub!(/\eIT\[(\d+)\]/i) { escape_icon_item($1.to_i, :state) }
    #---
    result.gsub!(/\eIE\[(\d+)\]/i)  { escape_icon_item($1.to_i, :element) }
    #---
    # From Script: メッセージ制御文字拡張 Ver1.1
    result.gsub!(/\eJ\[(\d+)\]/i) { actor_class_name($1.to_i) }
    result.gsub!(/\eK\[(\d+)\]/i) { actor_nickname($1.to_i) }
    result.gsub!(/\eT\[(\d+)\]/i) { escape_icon_item($1.to_i, :item) }
    result.gsub!(/\eW\[(\d+)\]/i) { escape_icon_item($1.to_i, :weapon) }
    result.gsub!(/\eA\[(\d+)\]/i) { escape_icon_item($1.to_i, :armour) }
    result.gsub!(/\eS\[(\d+)\]/i) { escape_icon_item($1.to_i, :skill) }
    #---
    #result.gsub!(/\eN/i) { "\n" }
    return result
  end
  
  #--------------------------------------------------------------------------
  # new method: escape_actor_class_name
  #--------------------------------------------------------------------------
  def escape_actor_class_name(actor_id)
    actor_id = $game_party.members[actor_id.abs].id if actor_id <= 0
    actor = $game_actors[actor_id]
    return "" if actor.nil?
    return actor.class.name
  end
  
  #--------------------------------------------------------------------------
  # new method: actor_subclass_name
  #--------------------------------------------------------------------------
  def escape_actor_subclass_name(actor_id)
    return "" unless $imported["YEA-ClassSystem"]
    actor_id = $game_party.members[actor_id.abs].id if actor_id <= 0
    actor = $game_actors[actor_id]
    return "" if actor.nil?
    return "" if actor.subclass.nil?
    return actor.subclass.name
  end
  
  #--------------------------------------------------------------------------
  # new method: escape_actor_nickname
  #--------------------------------------------------------------------------
  def escape_actor_nickname(actor_id)
    actor_id = $game_party.members[actor_id.abs].id if actor_id <= 0
    actor = $game_actors[actor_id]
    return "" if actor.nil?
    return actor.nickname
  end
  
  #--------------------------------------------------------------------------
  # new method: escape_icon_item
  #--------------------------------------------------------------------------
  def escape_icon_item(data_id, type)
    case type
    when :class
      return "" unless $imported["YEA-ClassSystem"]
      icon = $data_classes[data_id].icon_index
      name = $data_items[data_id].name
    when :item
      icon = $data_items[data_id].icon_index
      name = $data_items[data_id].name
    when :weapon
      icon = $data_weapons[data_id].icon_index
      name = $data_weapons[data_id].name
    when :armour
      icon = $data_armors[data_id].icon_index
      name = $data_armors[data_id].name
    when :skill
      icon = $data_skills[data_id].icon_index
      name = $data_skills[data_id].name
    when :state
      if LanguageFileSystem::enable_stat_icons
        icon = $data_states[data_id].icon_index
      else
        icon = 0
      end
      name = $data_states[data_id].name
    when :element
      if LanguageFileSystem::enable_elem_icons
        case data_id
        when 2
          icon = 59
        when 3
          icon = 144
        when 4
          icon = 145
        when 5
          icon = 146
        when 6
          icon = 149
        when 7
          icon = 148
        when 8
          icon = 147
        when 9
          icon = 150
        when 10
          icon = 151
        when 35
          icon = 176
        when 36
          icon = 18
        else
          icon = 0
        end
      else
        icon = 0
      end
      name = $data_system.elements[data_id]
    else; return ""
    end
    if icon != nil
      if icon > 0
        case type
        when :state
          if LanguageFileSystem::enable_stat_icons
            text = "\eI[#{icon}]"
          else
            text = name
          end
        when :element
          if LanguageFileSystem::enable_elem_icons
            text = "\eI[#{icon}]"
          else
            text = name
          end
        else
          text = "\eI[#{icon}]" + name
        end
      else
        text = name
      end
    else
      text = name
    end
    return text
  end
  
  #--------------------------------------------------------------------------
  # alias method: process_escape_character
  #--------------------------------------------------------------------------
  alias window_base_process_escape_character_ams process_escape_character
  def process_escape_character(code, text, pos)
    case code.upcase
    #---
    when 'FZ'
      contents.font.size = obtain_escape_param(text)
    when 'FN'
      text.sub!(/\[(.*?)\]/, "")
      font_name = $1.to_s
      font_name = Font.default_name if font_name.nil?
      contents.font.name = font_name.to_s
    #---
    when 'OC'
      colour = text_color(obtain_escape_param(text))
      contents.font.out_color = colour
    when 'OO'
      contents.font.out_color.alpha = obtain_escape_param(text)
    #---
    when 'AMSF'
      case obtain_escape_param(text)
      when 0; reset_font_settings
      when 1; contents.font.bold = !contents.font.bold
      when 2; contents.font.italic = !contents.font.italic
      when 3; contents.font.outline = !contents.font.outline
      when 4; contents.font.shadow = !contents.font.shadow
      end
    #---
    when 'PX'
      pos[:x] = obtain_escape_param(text)
    when 'PY'
      pos[:y] = obtain_escape_param(text)
    #---
    when 'PIC'
      text.sub!(/\[(.*?)\]/, "")
      bmp = Cache.picture($1.to_s)
      rect = Rect.new(0, 0, bmp.width, bmp.height)
      contents.blt(pos[:x], pos[:y], bmp, rect)
    #---
    else
      window_base_process_escape_character_ams(code, text, pos)
    end
  end
  
end # Window_Base

#==============================================================================
# ■ Window_ChoiceList
#==============================================================================

class Window_ChoiceList < Window_Command
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias window_choicelist_initialize_ams initialize
  def initialize(message_window)
    window_choicelist_initialize_ams(message_window)
    setup_message_font
  end
  
end # Window_ChoiceList

#==============================================================================
# ■ Window_ScrollText
#==============================================================================

class Window_ScrollText < Window_Base
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias window_scrolltext_initialize_ams initialize
  def initialize
    window_scrolltext_initialize_ams
    setup_message_font
  end
  
end # Window_ScrollText

#==============================================================================
# ■ Window_NameMessage
#==============================================================================

class Window_NameMessage < Window_Base
  
  #--------------------------------------------------------------------------
  # initialize
  #--------------------------------------------------------------------------
  def initialize(message_window)
    @message_window = message_window
    super(0, 0, Graphics.width, fitting_height(1))
    self.opacity = YEA::MESSAGE::NAME_WINDOW_OPACITY
    self.z = @message_window.z + 1
    self.openness = 0
    setup_message_font
    @close_counter = 0
    deactivate
  end
  
  #--------------------------------------------------------------------------
  # update
  #--------------------------------------------------------------------------
  def update
    super
    return if self.active
    return if self.openness == 0
    return if @closing
    @close_counter -= 1
    return if @close_counter > 0
    close
  end
  
  #--------------------------------------------------------------------------
  # start_close
  #--------------------------------------------------------------------------
  def start_close
    @close_counter = 4
    deactivate
  end
  
  #--------------------------------------------------------------------------
  # force_close
  #--------------------------------------------------------------------------
  def force_close
    @close_counter = 0
    deactivate
    close
  end
  
  #--------------------------------------------------------------------------
  # start
  #--------------------------------------------------------------------------
  def start(text, x_position)
    @text = text.clone
    set_width
    create_contents
    set_x_position(x_position)
    set_y_position
    refresh
    activate
    open
  end
  
  #--------------------------------------------------------------------------
  # set_width
  #--------------------------------------------------------------------------
  def set_width
    text = @text.clone
    dw = standard_padding * 2 + text_size(text).width
    dw += YEA::MESSAGE::NAME_WINDOW_PADDING * 2
    dw += calculate_size(text.slice!(0, 1), text) until text.empty?
    self.width = dw
  end
  
  #--------------------------------------------------------------------------
  # calculate_size
  #--------------------------------------------------------------------------
  def calculate_size(code, text)
    case code
    when "\e"
      return calculate_escape_code_width(obtain_escape_code(text), text)
    else
      return 0
    end
  end
  
  #--------------------------------------------------------------------------
  # calculate_escape_code_width
  #--------------------------------------------------------------------------
  def calculate_escape_code_width(code, text)
    dw = -text_size("\e").width - text_size(code).width
    case code.upcase
    when 'C', 'OC', 'OO'
      dw += -text_size("[" + obtain_escape_param(text).to_s + "]").width
      return dw
    when 'I'
      dw += -text_size("[" + obtain_escape_param(text).to_s + "]").width
      dw += 24
      return dw
    when '{'
      make_font_bigger
    when '}'
      make_font_smaller
    when 'FZ'
      contents.font.size = obtain_escape_param(text)
    when 'FN'
      text.sub!(/\[(.*?)\]/, "")
      font_name = $1.to_s
      font_name = Font.default_name if font_name.nil?
      contents.font.name = font_name.to_s
    when 'AMSF'
      case obtain_escape_param(text)
      when 0; reset_font_settings
      when 1; contents.font.bold = !contents.font.bold
      when 2; contents.font.italic = !contents.font.italic
      when 3; contents.font.outline = !contents.font.outline
      when 4; contents.font.shadow = !contents.font.shadow
      end
    else
      return dw
    end
  end
  
  #--------------------------------------------------------------------------
  # set_y_position
  #--------------------------------------------------------------------------
  def set_x_position(x_position)
    case x_position
    when 1 # Left
      self.x = @message_window.x
      self.x += YEA::MESSAGE::NAME_WINDOW_X_BUFFER
    when 2 # 3/10
      self.x = @message_window.x
      self.x += @message_window.width * 3 / 10
      self.x -= self.width / 2
    when 3 # Center
      self.x = @message_window.x
      self.x += @message_window.width / 2
      self.x -= self.width / 2
    when 4 # 7/10
      self.x = @message_window.x
      self.x += @message_window.width * 7 / 10
      self.x -= self.width / 2
    when 5 # Right
      self.x = @message_window.x + @message_window.width
      self.x -= self.width
      self.x -= YEA::MESSAGE::NAME_WINDOW_X_BUFFER
    end
    self.x = [[self.x, Graphics.width - self.width].min, 0].max
  end
  
  #--------------------------------------------------------------------------
  # set_y_position
  #--------------------------------------------------------------------------
  def set_y_position
    case $game_message.position
    when 0
      self.y = @message_window.height
      self.y -= YEA::MESSAGE::NAME_WINDOW_Y_BUFFER
    else
      self.y = @message_window.y - self.height
      self.y += YEA::MESSAGE::NAME_WINDOW_Y_BUFFER
    end
  end
  
  #--------------------------------------------------------------------------
  # refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    reset_font_settings
    @text = sprintf("\eC[%d]%s", YEA::MESSAGE::NAME_WINDOW_COLOUR, @text)
    draw_text_ex(YEA::MESSAGE::NAME_WINDOW_PADDING, 0, @text)
  end
  
end # Window_NameMessage

#==============================================================================
# ■ Window_Message
#==============================================================================

class Window_Message < Window_Base
  
  #--------------------------------------------------------------------------
  # alias method: initialize
  #--------------------------------------------------------------------------
  alias window_message_initialize_ams initialize
  def initialize
    window_message_initialize_ams
    setup_message_font
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: window_width
  #--------------------------------------------------------------------------
  def window_width
    return Variable.message_width
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: window_height
  #--------------------------------------------------------------------------
  def window_height
    return fitting_height(Variable.message_rows)
  end
  
  #--------------------------------------------------------------------------
  # alias method: create_all_windows
  #--------------------------------------------------------------------------
  alias window_message_create_all_windows_ams create_all_windows
  def create_all_windows
    window_message_create_all_windows_ams
    @name_window = Window_NameMessage.new(self)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: create_back_bitmap
  #--------------------------------------------------------------------------
  def create_back_bitmap
    @back_bitmap = Bitmap.new(width, height)
    rect1 = Rect.new(0, 0, Graphics.width, 12)
    rect2 = Rect.new(0, 12, Graphics.width, fitting_height(4) - 24)
    rect3 = Rect.new(0, fitting_height(4) - 12, Graphics.width, 12)
    @back_bitmap.gradient_fill_rect(rect1, back_color2, back_color1, true)
    @back_bitmap.fill_rect(rect2, back_color1)
    @back_bitmap.gradient_fill_rect(rect3, back_color1, back_color2, true)
  end
  
  #--------------------------------------------------------------------------
  # alias method: dispose_all_windows
  #--------------------------------------------------------------------------
  alias window_message_dispose_all_windows_ams dispose_all_windows
  def dispose_all_windows
    window_message_dispose_all_windows_ams
    @name_window.dispose
  end
  
  #--------------------------------------------------------------------------
  # alias method: update_all_windows
  #--------------------------------------------------------------------------
  alias window_message_update_all_windows_ams update_all_windows
  def update_all_windows
    window_message_update_all_windows_ams
    @name_window.update
    @name_window.back_opacity = self.back_opacity
    @name_window.opacity = self.opacity
  end
  
  #--------------------------------------------------------------------------
  # alias method: update_show_fast
  # Disabled for Paradox
  #--------------------------------------------------------------------------
  #alias window_message_update_show_fast_ams update_show_fast
  #def update_show_fast
  #  @show_fast = true if Input.press?(YEA::MESSAGE::TEXT_SKIP)
  #  window_message_update_show_fast_ams
  #end
  
  #--------------------------------------------------------------------------
  # overwrite method: input_pause
  # Disabled for Paradox
  #--------------------------------------------------------------------------
  #def input_pause
  #  self.pause = true
  #  wait(10)
  #  Fiber.yield until Input.trigger?(:B) || Input.trigger?(:C) ||
  #    Input.press?(YEA::MESSAGE::TEXT_SKIP)
  #  Input.update
  #  self.pause = false
  #end
  
  #--------------------------------------------------------------------------
  # overwrite method: convert_escape_characters
  #--------------------------------------------------------------------------
  def convert_escape_characters(text)
    result = super(text.to_s.clone)
    result = namebox_escape_characters(result)
    result = message_escape_characters(result)
    #result.gsub!(/\eN/i) { "\n" }
    return result
  end
  
  #--------------------------------------------------------------------------
  # new method: namebox_escape_characters
  #--------------------------------------------------------------------------
  def namebox_escape_characters(result)
    # Updated 08-10-2015 To Also Remove New Line
    result.gsub!(/\eN\<(.+?)\>\n/i)  { namewindow($1, 1) }
    result.gsub!(/\eN1\<(.+?)\>\n/i) { namewindow($1, 1) }
    result.gsub!(/\eN2\<(.+?)\>\n/i) { namewindow($1, 2) }
    result.gsub!(/\eNC\<(.+?)\>\n/i) { namewindow($1, 3) }
    result.gsub!(/\eN3\<(.+?)\>\n/i) { namewindow($1, 3) }
    result.gsub!(/\eN4\<(.+?)\>\n/i) { namewindow($1, 4) }
    result.gsub!(/\eN5\<(.+?)\>\n/i) { namewindow($1, 5) }
    result.gsub!(/\eNR\<(.+?)\>\n/i) { namewindow($1, 5) }
    
    result.gsub!(/\eN\<(.+?)\>\eN/i)  { namewindow($1, 1) }
    result.gsub!(/\eN1\<(.+?)\>\eN/i) { namewindow($1, 1) }
    result.gsub!(/\eN2\<(.+?)\>\eN/i) { namewindow($1, 2) }
    result.gsub!(/\eNC\<(.+?)\>\eN/i) { namewindow($1, 3) }
    result.gsub!(/\eN3\<(.+?)\>\eN/i) { namewindow($1, 3) }
    result.gsub!(/\eN4\<(.+?)\>\eN/i) { namewindow($1, 4) }
    result.gsub!(/\eN5\<(.+?)\>\eN/i) { namewindow($1, 5) }
    result.gsub!(/\eNR\<(.+?)\>\eN/i) { namewindow($1, 5) }
    
    result.gsub!(/\eN\<(.+?)\>/i)  { namewindow($1, 1) }
    result.gsub!(/\eN1\<(.+?)\>/i) { namewindow($1, 1) }
    result.gsub!(/\eN2\<(.+?)\>/i) { namewindow($1, 2) }
    result.gsub!(/\eNC\<(.+?)\>/i) { namewindow($1, 3) }
    result.gsub!(/\eN3\<(.+?)\>/i) { namewindow($1, 3) }
    result.gsub!(/\eN4\<(.+?)\>/i) { namewindow($1, 4) }
    result.gsub!(/\eN5\<(.+?)\>/i) { namewindow($1, 5) }
    result.gsub!(/\eNR\<(.+?)\>/i) { namewindow($1, 5) }
    return result
  end
  
  #--------------------------------------------------------------------------
  # new method: namebox
  #--------------------------------------------------------------------------
  def namewindow(text, position)
    @name_text = text
    @name_position = position
    return ""
  end
  
  #--------------------------------------------------------------------------
  # new method: message_escape_characters
  #--------------------------------------------------------------------------
  def message_escape_characters(result)
    result.gsub!(/\eAF\[(-?\d+)]/i) { change_face($1.to_i) }
    return result
  end
  
  #--------------------------------------------------------------------------
  # new method: change_face
  #--------------------------------------------------------------------------
  def change_face(actor_id)
    actor_id = $game_party.members[actor_id.abs].id if actor_id <= 0
    actor = $game_actors[actor_id]
    return "" if actor.nil?
    $game_message.face_name = actor.face_name
    $game_message.face_index = actor.face_index
    return ""
  end
  
  #--------------------------------------------------------------------------
  # alias method: new_page
  #--------------------------------------------------------------------------
  alias window_message_new_page_ams new_page
  def new_page(text, pos)
    adjust_message_window_size
    window_message_new_page_ams(text, pos)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: new_line_x
  #--------------------------------------------------------------------------
  def new_line_x
    return $game_message.face_name.empty? ? 0 : YEA::MESSAGE::FACE_INDENT_X
  end
  
  #--------------------------------------------------------------------------
  # new method: adjust_message_window_size
  #--------------------------------------------------------------------------
  def adjust_message_window_size
    self.height = window_height
    self.width = window_width
    create_contents
    update_placement
    self.x = (Graphics.width - self.width) / 2
    start_name_window
  end
  
  #--------------------------------------------------------------------------
  # new method: clear_name_window
  #--------------------------------------------------------------------------
  def clear_name_window
    @name_text = ""
    @name_position = 0
  end
  
  #--------------------------------------------------------------------------
  # new method: start_name_window
  #--------------------------------------------------------------------------
  def start_name_window
    return if @name_text == ""
    @name_window.start(@name_text, @name_position)
  end
  
  #--------------------------------------------------------------------------
  # overwrite method: fiber_main
  #--------------------------------------------------------------------------
  def fiber_main
    $game_message.visible = true
    update_background
    update_placement
    loop do
      process_all_text if $game_message.has_text?
      process_input
      $game_message.clear
      @gold_window.close
      @name_window.start_close
      Fiber.yield
      break unless text_continue?
    end
    close_and_wait
    $game_message.visible = false
    @fiber = nil
  end
  
  #--------------------------------------------------------------------------
  # alias method: open_and_wait
  #--------------------------------------------------------------------------
  alias window_message_open_and_wait_ams open_and_wait
  def open_and_wait
    clear_name_window
    adjust_message_window_size
    window_message_open_and_wait_ams
  end
  
  #--------------------------------------------------------------------------
  # alias method: close_and_wait
  #--------------------------------------------------------------------------
  alias window_message_close_and_wait_ams close_and_wait
  def close_and_wait
    @name_window.force_close
    window_message_close_and_wait_ams
  end
  
  #--------------------------------------------------------------------------
  # alias method: all_close?
  #--------------------------------------------------------------------------
  alias window_message_all_close_ams all_close?
  def all_close?
    return window_message_all_close_ams && @name_window.close?
  end
  
  #--------------------------------------------------------------------------
  # alias method: process_escape_character
  #--------------------------------------------------------------------------
  alias window_message_process_escape_character_ams process_escape_character
  def process_escape_character(code, text, pos)
    case code.upcase
    when 'W' # Wait
      wait(obtain_escape_param(text))
    else
      window_message_process_escape_character_ams(code, text, pos)
    end
  end
  
end # Window_Message

#==============================================================================
# 
# ■ Word
#==============================================================================
class Word
  #--------------------------------------------------------------------------
  # ● Object Initializer
  #--------------------------------------------------------------------------
  def initialize(word_data, face_name, face_index)
    # Words Will Still Be Filtered Later
    @words = word_data     #@words = Word.convert_new_escape_characters(word_data).split("\\n")
    @face_name = face_name
    @face_index = face_index
  end
  #--------------------------------------------------------------------------
  # ● Run
  #--------------------------------------------------------------------------
  def execute
    $game_message.face_name = @face_name
    $game_message.face_index = @face_index
    $game_message.background = 0
    $game_message.position = 2
    # YEA Script Will Still Filter This
    $game_message.add(@words)     #@words.each{|line| $game_message.add(line)}
  end
  
  #--------------------------------------------------------------------------
  # new method: convert_ace_message_system_new_escape_characters
  # Copy Of YEA - Ace Message System Function For Combat Dialoge
  # Updated For Paradox 08-10-2015
  #--------------------------------------------------------------------------
  def self.convert_new_escape_characters(result)
    #---
    result.gsub!(/\eFR/i) { "\eAMSF[0]" }
    result.gsub!(/\eFB/i) { "\eAMSF[1]" }
    result.gsub!(/\eFI/i) { "\eAMSF[2]" }
    result.gsub!(/\eFO/i) { "\eAMSF[3]" }
    result.gsub!(/\eFS/i) { "\eAMSF[4]" }
    #---
    result.gsub!(/\eAC\[([-+]?\d+)\]/i) { Word.escape_actor_class_name($1.to_i) }
    result.gsub!(/\eAS\[([-+]?\d+)\]/i) { Word.escape_actor_subclass_name($1.to_i) }
    result.gsub!(/\eAN\[([-+]?\d+)\]/i) { Word.escape_actor_nickname($1.to_i) }
    #---
    #---
    result.gsub!(/\\AC\[([-+]?\d+)\]/i) { Word.escape_actor_class_name($1.to_i) }
    result.gsub!(/\\AS\[([-+]?\d+)\]/i) { Word.escape_actor_subclass_name($1.to_i) }
    result.gsub!(/\\AN\[([-+]?\d+)\]/i) { Word.escape_actor_nickname($1.to_i) }
    #---
    result.gsub!(/\eN\[(\d+)\]/i) { $game_actors[$1.to_i].name rescue "" }
    #---
    #---
    result.gsub!(/\\n\[(\d+)\]/i) { $game_actors[$1.to_i].name rescue "" }
    #---
    result.gsub!(/\eNC\[(\d+)\]/i) { $data_classes[$1.to_i].name rescue "" }
    result.gsub!(/\eNI\[(\d+)\]/i) { $data_items[$1.to_i].name rescue "" }
    result.gsub!(/\eNW\[(\d+)\]/i) { $data_weapons[$1.to_i].name rescue "" }
    result.gsub!(/\eNA\[(\d+)\]/i) { $data_armors[$1.to_i].name rescue "" }
    result.gsub!(/\eNS\[(\d+)\]/i) { $data_skills[$1.to_i].name rescue "" }
    result.gsub!(/\eNT\[(\d+)\]/i) { $data_states[$1.to_i].name rescue "" }
    result.gsub!(/\eNE\[(\d+)\]/i)  { $data_system.elements[$1.to_i].to_s rescue ""  }
    #---
    #---
    result.gsub!(/\\NC\[(\d+)\]/i) { $data_classes[$1.to_i].name rescue "" }
    result.gsub!(/\\NI\[(\d+)\]/i) { $data_items[$1.to_i].name rescue "" }
    result.gsub!(/\\NW\[(\d+)\]/i) { $data_weapons[$1.to_i].name rescue "" }
    result.gsub!(/\\NA\[(\d+)\]/i) { $data_armors[$1.to_i].name rescue "" }
    result.gsub!(/\\NS\[(\d+)\]/i) { $data_skills[$1.to_i].name rescue "" }
    result.gsub!(/\\NT\[(\d+)\]/i) { $data_states[$1.to_i].name rescue "" }
    result.gsub!(/\\NE\[(\d+)\]/i)  { $data_system.elements[$1.to_i].to_s rescue ""  }
    #---
    result.gsub!(/\eEN\[(\d+)\]/i)  { $data_enemies[$1.to_i].name rescue "" }
    result.gsub!(/\ePG/i) { $game_party.gold }
    #---
    #---
    result.gsub!(/\\EN\[(\d+)\]/i)  { $data_enemies[$1.to_i].name rescue "" }
    result.gsub!(/\\PG/i) { $game_party.gold }
    #---
    result.gsub!(/\eIC\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :class) }
    result.gsub!(/\eII\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :item) }
    result.gsub!(/\eIW\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :weapon) }
    result.gsub!(/\eIA\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :armour) }
    result.gsub!(/\eIS\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :skill) }
    result.gsub!(/\eIT\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :state) }
    result.gsub!(/\eIE\[(\d+)\]/i)  { Word.escape_icon_item($1.to_i, :element) }
    #---
    #---
    result.gsub!(/\\IC\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :class) }
    result.gsub!(/\\II\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :item) }
    result.gsub!(/\\IW\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :weapon) }
    result.gsub!(/\\IA\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :armour) }
    result.gsub!(/\\IS\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :skill) }
    result.gsub!(/\\IT\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :state) }
    result.gsub!(/\\IE\[(\d+)\]/i)  { Word.escape_icon_item($1.to_i, :element) }
    #---
    #---
    # From Script: メッセージ制御文字拡張 Ver1.1
    result.gsub!(/\eJ\[(\d+)\]/i) { actor_class_name($1.to_i) }
    result.gsub!(/\eK\[(\d+)\]/i) { actor_nickname($1.to_i) }
    result.gsub!(/\eT\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :item) }
    result.gsub!(/\eW\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :weapon) }
    result.gsub!(/\eA\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :armour) }
    result.gsub!(/\eS\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :skill) }
    #---
    #---
    # From Script: メッセージ制御文字拡張 Ver1.1
    result.gsub!(/\\J\[(\d+)\]/i) { actor_class_name($1.to_i) }
    result.gsub!(/\\K\[(\d+)\]/i) { actor_nickname($1.to_i) }
    result.gsub!(/\\T\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :item) }
    result.gsub!(/\\W\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :weapon) }
    result.gsub!(/\\A\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :armour) }
    result.gsub!(/\\S\[(\d+)\]/i) { Word.escape_icon_item($1.to_i, :skill) }
    #---
    return result
  end
  
  #--------------------------------------------------------------------------
  # new method: escape_actor_class_name
  #--------------------------------------------------------------------------
  def self.escape_actor_class_name(actor_id)
    actor_id = $game_party.members[actor_id.abs].id if actor_id <= 0
    actor = $game_actors[actor_id]
    return "" if actor.nil?
    return actor.class.name
  end
  
  #--------------------------------------------------------------------------
  # new method: actor_subclass_name
  #--------------------------------------------------------------------------
  def self.escape_actor_subclass_name(actor_id)
    return "" unless $imported["YEA-ClassSystem"]
    actor_id = $game_party.members[actor_id.abs].id if actor_id <= 0
    actor = $game_actors[actor_id]
    return "" if actor.nil?
    return "" if actor.subclass.nil?
    return actor.subclass.name
  end
  
  #--------------------------------------------------------------------------
  # new method: escape_actor_nickname
  #--------------------------------------------------------------------------
  def self.escape_actor_nickname(actor_id)
    actor_id = $game_party.members[actor_id.abs].id if actor_id <= 0
    actor = $game_actors[actor_id]
    return "" if actor.nil?
    return actor.nickname
  end
  
  #--------------------------------------------------------------------------
  # new method: escape_icon_item
  #--------------------------------------------------------------------------
  def self.escape_icon_item(data_id, type)
    case type
    when :class
      return "" unless $imported["YEA-ClassSystem"]
      icon = $data_classes[data_id].icon_index
      name = $data_items[data_id].name
    when :item
      icon = $data_items[data_id].icon_index
      name = $data_items[data_id].name
    when :weapon
      icon = $data_weapons[data_id].icon_index
      name = $data_weapons[data_id].name
    when :armour
      icon = $data_armors[data_id].icon_index
      name = $data_armors[data_id].name
    when :skill
      icon = $data_skills[data_id].icon_index
      name = $data_skills[data_id].name
    when :state
      if LanguageFileSystem::enable_stat_icons
        icon = $data_states[data_id].icon_index
      else
        icon = 0
      end
      name = $data_states[data_id].name
    when :element
      if LanguageFileSystem::enable_elem_icons
        case data_id
        when 2
          icon = 59
        when 3
          icon = 144
        when 4
          icon = 145
        when 5
          icon = 146
        when 6
          icon = 149
        when 7
          icon = 148
        when 8
          icon = 147
        when 9
          icon = 150
        when 10
          icon = 151
        when 35
          icon = 176
        when 36
          icon = 18
        else
          icon = 0
        end
      else
        icon = 0
      end
      name = $data_system.elements[data_id]
    else; return ""
    end
    if icon != nil
      if icon > 0
        case type
        when :state
          if LanguageFileSystem::enable_stat_icons
            text = "\eI[#{icon}]"
          else
            text = name
          end
        when :element
          if LanguageFileSystem::enable_elem_icons
            text = "\eI[#{icon}]"
          else
            text = name
          end
        else
          text = "\eI[#{icon}]" + name
        end
      else
        text = name
      end
    else
      text = name
    end
    return text
  end
end

#========================================================================
# ** Word Wrapping Message Boxes, by: KilloZapit
#------------------------------------------------------------------------
# Changes message boxes so it will automatically wrap long lines.
#
# Note: I consider this script to be public domain, and put no
# restrictions on it's use whatsoever. My only request is that
# a link back to the script is provided so more people can
# access it if they want to.
#
# Version the Second:
#   Now strips color codes and icon codes so they don't break words.
#   Also calculates icon width along with text width for words.
# Version the Third:
#   Now also strips delays and other timing related codes.
#   Splits for non-icon control codes before counting icons.
#   Control codes can now break lines in case of font changes.
#   Added some comments to clarify some code.
# Version the Forth:
#   Fixed a small bug that might cause a error when counting icons.
#   Added a small notice for copyright questions.
# Version the Fifth:
#   Added "collapse" mode, which elimanates extra spaces.
#   Can now use "whitespace" mode outside of wordwrap mode if needed.
# Version the Sixth:
#   Fixed problems with collapsed whitespace not wraping words right.
# Version the Seventh:
#   Added option to add a margin to the right hand side of the window.
#------------------------------------------------------------------------
# Also adds the following new escape sequences:
#
# \ww  - Word Wrap: turns word wrap on if it's off
# \nw  - No Wrap: Turns word wrap off
# \ws  - WhiteSpace mode: Converts newlines to spaces (like HTML)
# \nl  - New Line: Preserves hard returns
# \cs  - Collapse whiteSpace: Eliminates extra spaces (also like HTML)
# \pre - PRE-formatted: Preserves spaces
# \br  - line BRake: manual newline for whitespace mode
# \rm  - Right Margin: extra space on the right side of the window
#========================================================================

# Standard config module.
module KZIsAwesome
  module WordWrap

    # change this if you don't want wordwrap on by default.
    DEFAULT_WORDWRAP = true

    # change this if you want white space mode on by default.
    DEFAULT_WHITESPACE = false
   
    # change this if you want white space mode on by default.
    DEFAULT_COLLAPSE = true
    
    # change this to add a right margin to the window.
    DEFAULT_RIGHT_MARGIN = 0

  end
end

class Window_Base < Window
  include KZIsAwesome::WordWrap

  alias_method :initialize_kz_window_base, :initialize
  def initialize(x, y, width, height)
    initialize_kz_window_base(x, y, width, height)
    @wordwrap = DEFAULT_WORDWRAP
    @convert_newlines = DEFAULT_WHITESPACE
    @collapse_whitespace = DEFAULT_COLLAPSE
    @right_margin = DEFAULT_RIGHT_MARGIN
    @lastc = "\n"
  end

  alias_method :process_character_kz_window_base, :process_character
  def process_character(c, text, pos)
    c = ' ' if @convert_newlines && c == "\n"
    if @wordwrap && c =~ /[ \t]/
      c = '' if @collapse_whitespace && @lastc =~ /[\s\n\f]/
      if pos[:x] + get_next_word_size(c, text) > contents.width - @right_margin
        process_new_line(text, pos)
      else
        process_normal_character(c, pos)
      end
      @lastc = c
    else
      @lastc = c
      process_character_kz_window_base(c, text, pos)
    end
  end

  def get_next_word_size(c, text)
    # Split text by the next space/line/page and grab the first split
    nextword = text.split(/[\s\n\f]/, 2)[0]
    if nextword
      icons = 0
      if nextword =~ /\e/i
        # Get rid of color codes and YEA Message system outline colors
        nextword = nextword.split(/\e[oOcC]+\[\d*\]/).join
        # Get rid of message timing control codes
        nextword = nextword.split(/\e[\.\|\^<>!]/).join
        # Split text by the first non-icon escape code
        # (the hH is for compatibility with the Icon Hues script)
        nextword = nextword.split(/\e[^iIhH]+/, 2)[0]
        # Erase and count icons in remaining text
        nextword.gsub!(/\e[iIhH]+\[[\d,]*\]/) do
          icons += 1
          ''
        end if nextword
      end
      wordsize = (nextword ? text_size(c + nextword).width : text_size( c ).width)
      wordsize += icons * 24
    else
      wordsize = text_size( c ).width
    end
    return wordsize
  end

  alias_method :process_escape_character_kz_window_base, :process_escape_character
  def process_escape_character(code, text, pos)
    #temp fix for Nil Class
    code = 'WW' if code == nil
    
    case code.upcase
    when 'WW'
      @wordwrap = true
    when 'NW'
      @wordwrap = false
    when 'WS'
      @convert_newlines = true
    when 'NL'
      @convert_newlines = false
    when 'CS'
      @collapse_whitespace = true
    when 'PRE'
      @collapse_whitespace = false
    when 'BR'
      process_new_line(text, pos)
      @lastc = "\n"
    when 'RM'
      @right_margin = obtain_escape_param(text)
    else
      process_escape_character_kz_window_base(code, text, pos)
    end

    # Recalculate the next word size and insert line breaks
    # (Needed primarily for font changes)
    if pos[:x] + get_next_word_size('', text) > contents.width
      process_new_line(text, pos)
    end
  end

end

#==============================================================================
#
# Fix in-battle word wrap & squishing.
#
#==============================================================================
class Window_BattleLog < Window_Selectable
  #--------------------------------------------------------------------------
  # ● Refresh
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    counter = -1
    #@lines.size.times {|i|
    @lines.each_with_index {|line, index|
      text = reformat_wrapped(line)
      txt_array = text.split("\n")
      if txt_array.size <= 1
        counter += 1
        #draw_line(index)
        draw_line_ex(counter, text)
      else
        txt_array.each{|new_line|
          counter += 1
          draw_line_ex(counter, new_line)
        }
      end
    }
  end
  
  #--------------------------------------------------------------------------
  # ● Draw Line
  #--------------------------------------------------------------------------
  def draw_line_ex(line_number, text)
    rect = item_rect_for_text(line_number)
    contents.clear_rect(rect)
    draw_text_ex(rect.x, rect.y, text)
  end
  
  #--------------------------------------------------------------------------
  # ● Reformat Wrapped
  #--------------------------------------------------------------------------
  def reformat_wrapped(s, width=60)
      lines = []
      line = ""
      s.split(/\s+/).each do |word|
        if line.size + word.size >= width
          lines << line
          line = word
        elsif line.empty?
         line = word
        else
         line << " " << word
       end
       end
       lines << line if line
      return lines.join "\n"
    end
end

#==============================================================================
#
# Enable Message Window Text Hiding.
#
#==============================================================================

=begin
===============================================================================
 Message Visibility by efeberk
 Version: RGSS3
===============================================================================
 This script will allow to player sets message window visible or unvisible with 
 a key.
 
 Example : Press F8 to hide message window and repress F8 to show message 
 window.
--------------------------------------------------------------------------------
=end

module EFE
  
  KEY = :F8

end

class Window_Message < Window_Base
  
  alias efeberk_window_message_update update
  def update
    efeberk_window_message_update
    if Input.trigger?(EFE::KEY)
      self.visible = !self.visible
      
      # Update For YEA - Ace Message System
      # Name Box Window
      @name_window.visible = self.visible if $imported["YEA-MessageSystem"]
      # Other Message Windows That Appear On Screen
      @gold_window.visible = self.visible
      @choice_window.visible = self.visible
      @number_window.visible = self.visible
      @item_window.visible = self.visible
    end
  end
  
end

#--------------------------------------------------------------------------
# АнтиЛаг (Anti-Lag for Damaging Floors)
#--------------------------------------------------------------------------
# Урон он местности считаем минусуем как только
# срабатывает отрисовка хп. (Кот Шредингера, так сказать...)
#--------------------------------------------------------------------------
class Game_Actor < Game_Battler
  #убрал проверку плитки, чтобы она не проверялась отдельно для каждого
  #переместил в функцию уровнем выше для единоразового детекта
  def on_player_walk
    @result.clear
    if $game_player.normal_walk?
      turn_end_on_map
      states.each {|state| update_state_steps(state) }
      show_added_states
      show_removed_states
    end
  end
  
  $terra_steps = 0
  # мог бы высчитывать дамаг здесь, но даже такие простые операции как 
  # + вызывают трудности в быстродействии. Придётся наговнокодить в
  # функции отрисовки... Чего не сделаешь ради оптимизации...
  def execute_floor_damage
    $terra_steps +=1
    
    #это прорисовка красного эффекта. Немного лагов от него всё же есть
    #с быстрым движением
    perform_map_damage_effect if $game_party.floor_damage_rate > 0
  end
end


class Game_Party < Game_Unit
  def on_player_walk
    members.each {|actor| actor.on_player_walk }
    members[0].check_floor_effect
  end
end  
  

class Window_Base < Window
  def draw_actor_hp(actor, x, y, width = 124)
    
    if $terra_steps > 0
      $game_party.alive_members.each do |x|
        x.hp -= ($terra_steps*x.mhp*$game_party.floor_damage_rate*0.02).to_i
        if x.hp == 0
          x.hp = 1
        end
      end
      $terra_steps = 0
    end
    
    #Почему-то не смог воспользоваться super
    draw_gauge(x, y, width, actor.hp_rate, hp_gauge_color1, hp_gauge_color2)
    change_color(system_color)
    draw_text(x, y, 30, line_height, Vocab::hp_a)
    draw_current_and_max_values(x, y, width, actor.hp, actor.mhp,
      hp_color(actor), normal_color)
  end
end

#--# Basic Enemy HP Bars Lite v 1.1c
#
# Adds options for hp/mp bars, enemy name, state icons, and even targetting icon
#  to appear over the enemy in battle.
#
# Usage: Plug and play, customize as needed.
#       New Notetag: <BOSS> determines if enemy is a boss or not.
#                    <HIDE NAME> name displays as ???
#
#------#
#-- Script by: V.M of D.T
#
#- Questions or comments can be:
#    posted on the thread for the script
#    given by email: sumptuaryspade@live.ca
#    provided on facebook: http://www.facebook.com/DaimoniousTailsGames
#   All my other scripts and projects can be found here: http://daimonioustails.weebly.com/
#
#--- Free to use in any project, commercial or non-commercial, with credit given
#--Though a donation's always a nice way to say thank you~ (I also accept actual thank you's)
 
module DTP_HP
  #Whether to include the hp bar or not
  USE_HP_BAR = true
  #Whether to include an mp bar or not
  USE_MP_BAR = false
  #Whether or not to include state icons
  USE_STATES = true
  #Whether to display enemy name or not
  USE_TEXT = false
  #Display HP numbers
  USE_HP_TEXT = false
  #Icon to be displayed over current target, set to 0 to disable
  DISPLAY_ICON = 0
 
  #Display hp bar above the enemy, false for below
  ABOVE_MONSTER = true
  #Offset the hp bar along the x-axis(left,right)
  BAR_OFFSET_X = 0
  #Offset the hp bar along the y-axis(up,down)
  BAR_OFFSET_Y = 0
 
  #First color for the mp bar gradient
  MP_COLOR_BAR_1 = Color.new(0,175,255)
  #Second color fot the mp bar gradient
  MP_COLOR_BAR_2 = Color.new(0,0,255)
 
  #Show bars only when specific actor in party. Array format. Example: [8,7]
  #Set to [] to not use actor only
  SPECIFIC_ACTOR = []
  #Show enemy hp bar only if certain state is applied (like a scan state)
  #Set to 0 to not use state only
  SCAN_STATE = 0
  #Enemies will show hp bar as long as they have been affected by scan state
  #at least once before
  SCAN_ONCE = false
  #Hp bars will only show when you are targetting a monster
  ONLY_ON_TARGET = false
end
 
class Sprite_Battler
  alias hpbar_update update
  alias hpbar_dispose dispose
  def update
    hpbar_update
    return unless @battler.is_a?(Game_Enemy)
    if @battler
      update_hp_bar
    end
  end
  def update_hp_bar
    setup_bar if @hp_bar.nil?
    if $game_temp.battler_graphic_hide != true
    determine_visible
    else
      @hp_bar.visible = false
    end
    return unless @hp_bar.visible
    @hp_bar.update
    if @hp_bar.contents_opacity != self.opacity
      @hp_bar.contents_opacity = self.opacity
    end
    @hp_bar.y = self.y + DTP_HP::BAR_OFFSET_Y - self.height - @hp_bar.height
    @hp_bar.y = self.y + DTP_HP::BAR_OFFSET_Y unless $game_system.conf[:mod_hpgauge] == 1 || $game_system.conf[:mod_hpgauge] == 3
    @hp_bar.y = 0 if @hp_bar.y < 0
    @hp_bar.y = 290 if @hp_bar.y > 290
    @hp_bar.y = -12 if @battler.boss?
    @hp_bar.contents.clear
    width = @hp_bar.contents.width - @hp_bar.padding
    hp_width = @battler.hp_rate
    yy = 0
    if DTP_HP::DISPLAY_ICON > 0
      if SceneManager.scene.is_a?(Scene_Battle) &&
        SceneManager.scene.enemy_window &&
        SceneManager.scene.enemy_window.active &&
        SceneManager.scene.target_window_index == @battler.index
          @hp_bar.draw_icon(DTP_HP::DISPLAY_ICON,@hp_bar.contents.width/2,yy)
      end
      yy += 24
    end
    if DTP_HP::USE_TEXT and !@battler.boss?
      if @battler.hide_name
        @hp_bar.draw_text(0,yy,width,24,"???",2)
      else
        @hp_bar.draw_text(0,yy,width,24,@battler.name,2)
      end
      yy += 24
    end
    if $game_system.conf[:mod_hpgauge] != 0 && $game_system.conf[:mod_hpgauge] != nil
      height = @battler.boss? ? 16 : 8
#      yy -= 12 if !DTP_HP::USE_HP_TEXT
      yy += 12
      if @special
        @hp_bar.draw_enemy_hp(@battler, @hp_bar.padding/2, yy, width, height, $game_system.conf[:mod_hpgauge] != 3 && $game_system.conf[:mod_hpgauge] != 4)
      else
        if $game_system.conf[:mod_hpgauge] != 3 && $game_system.conf[:mod_hpgauge] != 4
          @hp_bar.draw_actor_hp_notext(@battler, @hp_bar.padding/2, yy, width)
        else
          @hp_bar.draw_enemy_hp(@battler, @hp_bar.padding/2, yy, width)
        end
      end
      yy += 12
    end
    if DTP_HP::USE_TEXT and @battler.boss?
      if @battler.hide_name
        @hp_bar.draw_text(0,12,width,24,"???",2)
      else
        @hp_bar.draw_text(0,12,width,24,@battler.name,2)
      end
      if @special
        @hp_bar.change_color(@hp_bar.system_color)
        @hp_bar.draw_text(0,24,width,24,Vocab::hp_a)
        @hp_bar.change_color(@hp_bar.normal_color)
      end
    end
    if DTP_HP::USE_MP_BAR and !@battler.boss?
      mp_width = @battler.mp_rate * width
      @gauge_hp_y_for_nothing_at_all = yy
      @hp_bar.draw_gauge(@hp_bar.padding/2,yy,width,@battler.mp_rate,DTP_HP::MP_COLOR_BAR_1,DTP_HP::MP_COLOR_BAR_2)
      yy += 24
    end
    if DTP_HP::USE_STATES
#      xx = 29
#      yy += 18 if @battler.boss?
#      yy -= 20
#      draw_actor_icons(@battler, xx, yy,72)
#      @battler.states.each do |state|
#        @hp_bar.draw_icon(state.icon_index,xx,yy)
#        xx += 22
#      end
    end
  end
  def setup_bar
    @special = Module.const_defined?(:SPECIAL_GAUGES)
    if @battler.boss?
      @hp_bar = Window_Base.new(0,-12,Graphics.width,96)
    else
      height = 36
      height += 24 if DTP_HP::DISPLAY_ICON > 0
      height += 24 if DTP_HP::USE_TEXT
      height += 24 if DTP_HP::USE_HP_BAR
      height += 24 if DTP_HP::USE_MP_BAR
      height += 24 if DTP_HP::USE_STATES
      @hp_bar = Window_Base.new(0,0,124,height)
      @hp_bar.x = self.x - @hp_bar.width / 2 + DTP_HP::BAR_OFFSET_X
      if @battler.lefx != 0 && $game_troop.members.size != 1
        @hp_bar.x = self.x - @hp_bar.width / 2 + DTP_HP::BAR_OFFSET_X + @battler.lefx - 300
      end
      @hp_bar.y = self.y + DTP_HP::BAR_OFFSET_Y - self.height - @hp_bar.height
      @hp_bar.y = self.y + DTP_HP::BAR_OFFSET_Y unless $game_system.conf[:mod_hpgauge] == 1 || $game_system.conf[:mod_hpgauge] == 3
      @hp_bar.x = 0 if @hp_bar.x < 0
      @hp_bar.y = 0 if @hp_bar.y < 0
      @hp_bar.y = 290 if @hp_bar.y > 290
    end
    @hp_bar.opacity = 0
    @hp_bar.z = self.z + 1
    @hp_bar.viewport = self.viewport
  end
  def determine_visible
    if !@battler.alive? && !@battler.hidden?
      if @special
        if @hp_bar.gauges[[@hp_bar.padding/2,@gauge_hp_y_for_nothing_at_all]]
          @hp_bar.visible = false if @hp_bar.gauges[[@hp_bar.padding/2,@gauge_hp_y_for_nothing_at_all]].cur_val == 0
        end
      else
        @hp_bar.visible = false
      end
      if DTP_HP::SCAN_ONCE and DTP_HP::SCAN_STATE == 1
        $game_party.monster_scans[@battler.enemy_id] = true
      end
      return if !@battler.alive?
    end
    @hp_bar.visible = true
    if DTP_HP::SCAN_STATE != 0
      @hp_bar.visible = false
      @hp_bar.visible = true if @battler.state?(DTP_HP::SCAN_STATE)
      if DTP_HP::SCAN_ONCE
        @hp_bar.visible = true if $game_party.monster_scans[@battler.enemy_id] == true
        $game_party.monster_scans[@battler.enemy_id] = true if @hp_bar.visible
      end
    end
    if !DTP_HP::SPECIFIC_ACTOR.empty?
      @hp_bar.visible = false unless DTP_HP::SCAN_STATE != 0
      DTP_HP::SPECIFIC_ACTOR.each do |i|
        next unless $game_party.battle_members.include?($game_actors[i])
        @hp_bar.visible = true
      end
    end
    if DTP_HP::ONLY_ON_TARGET
      return unless SceneManager.scene.is_a?(Scene_Battle)
      return unless SceneManager.scene.enemy_window
      @hp_bar.visible = SceneManager.scene.target_window_index == @battler.index
      @hp_bar.visible = false if !SceneManager.scene.enemy_window.active
    end
  end
  def dispose
    @hp_bar.dispose if @hp_bar
    hpbar_dispose
  end
end

class Window_Base
  def draw_actor_hp_notext(actor, x, y, width = 124)
    if actor.id != 150 && actor.id != 499
      draw_gauge(x, y, width, actor.hp_rate, hp_gauge_color1, hp_gauge_color2)
    else
      draw_gauge(x, y, width, 1, hp_gauge_color1, hp_gauge_color2)
    end
    change_color(system_color)
    draw_text(x, y, 30, line_height, Vocab::hp_a)
    change_color(normal_color)
    draw_actor_icons(actor, x+21, y+22,72)
  end
end
 
class Scene_Battle
  attr_reader  :enemy_window
  def target_window_index
    begin
    @enemy_window.enemy.index
    rescue
      return -1
    end
  end
end
 
class Game_Party
  alias hp_bar_init initialize
  attr_accessor  :monster_scans
  def initialize
    hp_bar_init
    @monster_scans = []
  end
end
 
class Game_Enemy
  def boss?
    self.enemy.note =~ /<BOSS>/
  end
  def lefx
    if self.enemy.note =~ /<SHIFT\s?(\d+)>/i
      return $1.to_i
    else
      return 0
    end
  end
  def hide_name
    self.enemy.note =~ /<HIDE NAME>/
  end
end

def convert_to_short (value)
  result = value
  if value.is_a? Numeric
    value = value / 1.0 #просто чтобы не было неожиданностей
    if value >= 1e6 
      i = 0
      value /= 1e6
      while value > 1e3 do
        value /= 1e3
        i+=1
      end
      
      numsDG = ["МЛН","МЛРД","ТРЛН","КВДР","КВНТ","СКСТ","СПТЛ","ОКТЛ","НОНЛ","ДЦЛН"]
      result = (((value*1e3).round)/1e3).to_s.slice(0,7)
      if i<=numsDG.size-1
        result += numsDG[i]
      else
        i-=numsDG.size.to_f
        i+=1
        enm = ""
        begin
          enm = (97+(i%26-1).round).chr + enm
          i -= i%26
          i /= 26
        end while i>=1
        result += enm
      end
    end
  end
  return result.to_s.strip
end

class Window_Base < Window
  def draw_enemy_hp(actor, x, y, width = 124)
    if actor.id != 150 && actor.id != 499 
      draw_gauge(x, y, width, actor.hp_rate, hp_gauge_color1, hp_gauge_color2)
      change_color(system_color)
      draw_text(x, y, 30, line_height, Vocab::hp_a)
      draw_current_and_max_values_enemy(x, y, width, actor.hp, actor.mhp, hp_color(actor), normal_color)
      draw_actor_icons(actor, x+21, y+22,72)
    else
      draw_gauge(x, y, width, 1, hp_gauge_color1, hp_gauge_color2)
      change_color(system_color)
      draw_text(x, y, 30, line_height, Vocab::hp_a)
      change_color(normal_color)
      draw_text(x + 64, y, 68, line_height, "???")
      draw_actor_icons(actor, x+21, y+22,72)
    end
  end
  #---тут рисуем состояние группы в главном меню
  def draw_current_and_max_values_enemy(x, y, width, current, max, color1, color2)
    change_color(color1)
    xr = x + width
    draw_text(xr - 65, y, 68, line_height, convert_to_short(current), 2)
  end
end

#==============================================================================
# 
# ▼ End of File
# 
#==============================================================================